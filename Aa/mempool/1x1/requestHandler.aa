$parameter MEMPOOL_WORD_SIZE		8
$parameter MEMPOOL_PAGE_SIZE		512
$parameter LOG_MEMPOOL_PAGE_SIZE 	9
$parameter MAX_SIZE_OF_REQUEST_IN_WORDS 1024
$parameter MAX_MEMPOOL_SIZE_IN_PAGES    1024

$pipe REQUEST_PIPE: $uint<64> $depth 2
$pipe RESPONSE_PIPE: $uint<64> $depth 2

$constant MEMPOOL_SIZE_MASK : $uint<32> := {MAX_MEMPOOL_SIZE_IN_PAGES - 1}
$constant MEMPOOL_BUFFER_SIZE_MASK : $uint<32> := {{MAX_MEMPOOL_SIZE_IN_PAGES * MAX_MEMPOOL_SIZE_IN_PAGES} - 1}


$storage mempool_array   : $array [ {{{MEMPOOL_PAGE_SIZE * MAX_MEMPOOL_SIZE_IN_PAGES}*MEMPOOL_WORD_SIZE}*8} ] $of $uint< {8*MEMPOOL_WORD_SIZE} >

$module [requestHandlerDaemon]
	$in () $out () $is
{

	$branchblock[loop] {

		// optimize but pipeline depth = 1.
		$dopipeline $depth 1 $fullrate
			$merge $entry loopback
				$phi request := REQUEST_PIPE $on $entry, $loopback
			$endmerge

			$volatile $call parseRequest  (request)
					(is_alloc_from_head 
						is_alloc_from_tail
						is_dealloc 
						is_read 
						is_write
						request_tag
						base_address
						number_of_items_requested)
						
					
			$volatile is_alloc_dealloc := ($reduce | is_alloc_from_head is_alloc_from_tail is_dealloc)
			$guard (is_alloc_dealloc)
				$call mempoolAllocator 
					(is_alloc_from_head is_alloc_from_tail is_dealloc request_tag number_of_items_requested)
							 	()
			$guard (is_read)
				$call memReadAndSendResponse 
					(request_tag base_address number_of_items_requested stride) ()
			$guard (is_write)
				$call memWriteAndSendResponse 
					(request_tag base_address number_of_items_requested stride) ()

		$while 1
	}
}


$module [mempoolAllocator]
	$in (
		init: $uint<1>
		is_alloc_from_head is_alloc_from_tail is dealloc: $uint<1>
		request_tag : $uint<32>
		number_of_pages_requested: $uint<32>
	    )
	$out ()
$is
{
	$storage requester_array : $array [ MAX_MEMPOOL_SIZE_IN_PAGES ] $of $uint< 32 >
	$storage head_pointer tail_pointer number_of_free_pages: $uint<16>

	$guard (init)
		head_pointer := 0
	$guard (init)
		tail_pointer := 0
	$guard (init)
		number_of_free_pages := MAX_MEMPOOL_SIZE_IN_PAGES

	
	nfp := number_of_free_pages
	$volatile not_enough_pages := (nfp < number_of_pages_requested)


	old_head := head_pointer
	old_tail := tail_pointer
	

	$volatile dealloc_from_head :=
		(is_dealloc & (requester_array[ ((old_head-1) & MEMPOOL_SIZE_MASK) ] == request_tag))
	$volatile dealloc_from_tail :=
		(is_dealloc & (requester_array[ ((old_tail+1) & MEMPOOL_SIZE_MASK) ] == request_tag))
	$volatile illegal_dealloc := (is_dealloc & (~ (dealloc_from_head | dealloc_from_tail)))

	$volatile status := ($bitcast ($uint<32>) (not_enough_pages | illegal_dealloc))
	$guard (~status)
		number_of_free_pages := 
			($mux is_dealloc (nfp + number_of_pages_requested) (nfp - number_of_pages_requested))


	$volatile np_16 := ($bitcast ($uint<16>) number_of_pages_requested)

	// allocate logic.
	$volatile alloc_head := (is_alloc_from_head & (~status))
	$guard (alloc_head)
		head_pointer := ((old_head + np_16) & MEMPOOL_SIZE_MASK)
	$guard (alloc_head)
		requester_array[old_head] := request_tag
		
	$volatile alloc_tail := (is_alloc_from_tail & (~status))
	$guard (alloc_tail)
		tail_pointer := ((old_tail - np_16) & MEMPOOL_SIZE_MASK)
	$guard (alloc_tail)
		requester_array[old_tail] := request_tag

	$volatile base_address := ($bitcast ($uint<32>)
					(($mux is_alloc_from_head old_head (tail_pointer + 1)) & $zero< LOG_MEMPOOL_PAGE_SIZE >))
		
	

	RESPONSE_PIPE := status
	// request tag
	RESPONSE_PIPE := request_tag

	// base address (only in alloc case).
	$guard (is_dealloc)
		RESPONSE_PIPE := base_address
}

		
		
				
$opaque $module [memReadAndSendResponse]
	$in (request_tag base_address number_of_dwords stride: $uint<32>)
	$out () $is
{
			
	RESPONSE_PIPE := 0
	RESPONSE_PIPE := request_tag

	$branchblock[loop] {
		$dopipeline $depth 15 $fullrate 

			$merge $entry $loopback
				$phi I := $zero<16> $on $entry nI $on $loopback
				$phi A := $zero<32> $on $entry nA $on $loopback
			$endmerge

			$volatile nI := (I + 1)
			$volatile nA := (A + stride)
		
			$volatile continue_flag := (nI == number_of_dwords)
			$volatile A_masked := (A & MEMPOOL_BUFFER_SIZE_MASK)

			D := mempool_array[A_masked]
			RESPONSE_PIPE := D

		$while continue_flag
	}
}
 
$opaque $module [memWriteAndSendResponse]
	$in (request_tag base_address number_of_dwords stride: $uint<32>)
	$out () $is
{
			
	RESPONSE_PIPE := 0
	RESPONSE_PIPE := request_tag

	$branchblock[loop] {
		$dopipeline $depth 15 $fullrate 

			$merge $entry $loopback
				$phi I := $zero<16> $on $entry nI $on $loopback
				$phi A := $zero<32> $on $entry nA $on $loopback
				$phi X := REQUEST_PIPE $on $entry, $loopback
			$endmerge

			$volatile nI := (I + 1)
			$volatile nA := (A + stride)
		
			$volatile continue_flag := (nI == number_of_dwords)
			$volatile A_masked := (A & MEMPOOL_BUFFER_SIZE_MASK)

			mempool_array[A_masked] := X

		$while continue_flag
	}
}
 
