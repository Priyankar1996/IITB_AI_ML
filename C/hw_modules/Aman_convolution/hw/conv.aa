//$record [structx_x__SizedTensorCustom] < $array [16384] $of $uint<64> > 
//$storage T:structx_x__SizedTensorCustom

$parameter IP_DEPTH 400
$parameter K_DEPTH 400
$pipe kernel_pipe1 : $uint<16> $depth K_DEPTH
$pipe kernel_pipe2 : $uint<16> $depth K_DEPTH
$pipe kernel_pipe3 : $uint<16> $depth K_DEPTH
$pipe input_pipe1 : $uint<16> $depth IP_DEPTH
$pipe input_pipe2 : $uint<16> $depth IP_DEPTH
$pipe input_pipe3 : $uint<16> $depth IP_DEPTH
$pipe size_pipe : $uint<16> $depth 11
$pipe kernel_done_pipe : $uint<1> $depth 1
$pipe input_done_pipe : $uint<8> $depth 1

// Load the kernel channel into the kernel pipes
$module [loadKernelChannel]
$in (start_add : $uint<64> num_chl : $uint<16> )
$out ()
$is
{   
    row_size := (num_chl + (num_chl << 1))
    sh_start := (start_add>>2)
    fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][sh_start])
    my_fetch := ->(fetch_addr)
    ea1 := (start_add + ( $bitcast ($uint<64> ) row_size))
    ea2 := (start_add + ( $bitcast ($uint<64> ) (row_size<<1)))
    ea3 := (ea2 + ( $bitcast ($uint<64> )row_size))
    first_fill := (start_add == 0)
    $guard (~first_fill) start_next := input_done_pipe
    $branchblock [load_block]
    {
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi mycount := start_add $on $entry nmycount $on $loopback
        $phi fetch_val := my_fetch $on $entry nfetch_val $on $loopback
        $endmerge
        my_num1 := ((3-(mycount&3))<<4)
        $volatile nmycount := (mycount + 1)
        var_val := ($bitcast ($uint<16>) (fetch_val>>my_num1))
        send_to_1 := (mycount < ea1)
        send_to_2 := ((~send_to_1) & (mycount < ea2))
        send_to_3 := (mycount >= ea2)
        $guard (send_to_1) kernel_pipe1 := var_val
        $guard (send_to_2) kernel_pipe2 := var_val
        $guard (send_to_3) kernel_pipe3 := var_val
        fn := ((nmycount& 3) == 0)
        fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(nmycount >>2)])
        $guard (fn) fv := ->(fetch_addr)
        nfetch_val := ($mux fn fv fetch_val)
        $while (mycount < (ea3-1))
    }
    size_pipe := num_chl
}

// Access the input tensor and write to iput pipe
$module [access_T]
$in(row_in chl_in ct: $uint<16> )
$out()
$is
{
    $branchblock [access_block]
    {
        m_factor := ($bitcast ($uint<32>) (ct * chl_in))
        m2_factor := (m_factor << 1) 
        
        // Fetch first word for each row
        fetch_add1 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][($bitcast ($uint<64>) 0)])
        my_fetch1 := ->(fetch_add1)
        fetch_add2 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][($bitcast ($uint<64>) (m_factor >> 2))])
        my_fetch2 := ->(fetch_add2)
        fetch_add3 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][($bitcast ($uint<64>) (m_factor >> 1))])
        my_fetch3 := ->(fetch_add3)
        
        // Pipeline for sending inputs
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address1 := ($bitcast ($uint<64>) 0) $on $entry n_address1 $on $loopback
        $phi address2 := ($bitcast ($uint<64>) m_factor) $on $entry n_address2 $on $loopback
        $phi address3 := ($bitcast ($uint<64>) m2_factor) $on $entry n_address3 $on $loopback
        $phi mycounter := ($bitcast ($uint<32>) 1) $on $entry n_mycounter $on $loopback
        $phi fetch_val1 := my_fetch1 $on $entry n_fetch_val1 $on $loopback
        $phi fetch_val2 := my_fetch2 $on $entry n_fetch_val2 $on $loopback
        $phi fetch_val3 := my_fetch3 $on $entry n_fetch_val3 $on $loopback
        $phi row1 := ($bitcast ($uint<16>) 0) $on $entry n_row1 $on $loopback
        $phi row2 := ($bitcast ($uint<16>) 1) $on $entry n_row2 $on $loopback
        $phi row3 := ($bitcast ($uint<16>) 2) $on $entry n_row3 $on $loopback
        $endmerge
        
        next_row := (mycounter == m_factor)
        $volatile n_mycounter := ($mux next_row 1 (mycounter + 1))
        $volatile continue := (n_row1 < row_in)
        
        $volatile my_num1 := ((3-(address1 & 3))<<4)
        $volatile var_val1 := ($bitcast ($uint<16>) (fetch_val1>>my_num1))
        $volatile n_row1 := ($mux next_row (row1 + 1) row1)
        $volatile n_address1 := (address1 + 1)
        $volatile fn1 := (((n_address1 >> 2) != (address1 >> 2)) & continue)
        fetch_addr1 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(n_address1 >> 2)])
        $guard (fn1) fv1 := ->(fetch_addr1)
        $volatile n_fetch_val1 := ($mux fn1 fv1 fetch_val1)
        input_pipe1 := var_val1

        $volatile my_num2 := ((3-(address2 & 3))<<4)
        $volatile var_val2 := ($bitcast ($uint<16>) (fetch_val2>>my_num2))
        $volatile n_row2 := ($mux next_row (row2 + 1) row2)
        $volatile n_address2 := (address2 + 1)
        $volatile fn2 := (((n_address2 >> 2) != (address2 >> 2)) & continue)
        fetch_addr2 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(n_address2 >> 2)])
        $guard (fn2) fv2 := ->(fetch_addr2)
        $volatile n_fetch_val2 := ($mux fn2 fv2 fetch_val2)
        input_pipe2 := var_val2

        $volatile my_num3 := ((3-(address3 & 3))<<4)
        $volatile var_val3 := ($bitcast ($uint<16>) (fetch_val3>>my_num3))
        $volatile n_row3 := ($mux next_row (row3 + 1) row3)
        $volatile n_address3 := (address3 + 1)
        $volatile fn3 := (((n_address3 >> 2) != (address3 >> 2)) & continue)
        $volatile send_now3 := (row1 < row_in)
        fetch_addr3 := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(n_address3 >> 2)])
        $guard (fn3) fv3 := ->(fetch_addr3)
        $volatile n_fetch_val3 := ($mux fn3 fv3 fetch_val3)
        $guard (send_now3) input_pipe3 := var_val3

        $while continue
    }
}

// Perform convolution operation
$module [convolve]
$in ()
$out ()
$is
{
    $pipe conv_ip1 : $uint<16> $depth IP_DEPTH
    $pipe conv_ip2 : $uint<16> $depth IP_DEPTH
    $pipe conv_ip3 : $uint<16> $depth IP_DEPTH
    $pipe conv_k1 : $uint<16> $depth K_DEPTH
    $pipe conv_k2 : $uint<16> $depth K_DEPTH
    $pipe conv_k3 : $uint<16> $depth K_DEPTH
    $branchblock [conv_block]
    {
        $merge $entry loopback
        $endmerge

        num_row := (num_out_pipe - 1)
        num_col := (num_out_pipe - 1)
        num_chl := (size_pipe - 1)
        
        $dopipeline $depth 15 $buffering 1 $fullrate
        $merge $entry $loopback
        $phi acc := ($bitcast ($int<16>) 0) $on $entry nacc $on $loopback
        $phi row := ($bitcast ($uint<16>) 0) $on $entry n_row $on $loopback
        $phi col := ($bitcast ($uint<16>) 0) $on $entry n_col $on $loopback
        $phi num := ($bitcast ($uint<2>) 0) $on $entry n_num $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $endmerge

        $volatile read_ip := ((col == 0) | (num == 2))
        $guard (read_ip) temp2_1 := input_pipe1
        $guard (read_ip) temp2_2 := input_pipe2
        $guard (read_ip) temp2_3 := input_pipe3
        $guard (~read_ip) temp1_1 := conv_ip1
        $guard (~read_ip) temp1_2 := conv_ip2
        $guard (~read_ip) temp1_3 := conv_ip3

        iread1 := ($mux read_ip temp2_1 temp1_1)
        iread2 := ($mux read_ip temp2_2 temp1_2)
        iread3 := ($mux read_ip temp2_3 temp1_3)
        
        $volatile write_input := ((col < num_col) & (num > 0))
        $guard (write_input) conv_ip1 := iread1
        $guard (write_input) conv_ip2 := iread2
        $guard (write_input) conv_ip3 := iread3

        ival1 := ($bitcast ($int<16>) iread1)
        ival2 := ($bitcast ($int<16>) iread2)
        ival3 := ($bitcast ($int<16>) iread3)

        $volatile read_k := ((col == 0) & (row == 0))
        $guard (read_k) tempk1_1 := kernel_pipe1
        $guard (read_k) tempk1_2 := kernel_pipe2
        $guard (read_k) tempk1_3 := kernel_pipe3
        $guard (~read_k) tempk2_1 := conv_k1
        $guard (~read_k) tempk2_2 := conv_k2
        $guard (~read_k) tempk2_3 := conv_k3

        kread1 := ($mux read_k tempk1_1 tempk2_1)
        kread2 := ($mux read_k tempk1_2 tempk2_2)
        kread3 := ($mux read_k tempk1_3 tempk2_3)
        kval1 := ($bitcast ($int<16>) kread1)
        kval2 := ($bitcast ($int<16>) kread2)
        kval3 := ($bitcast ($int<16>) kread3)
        
        mul_val1 := ($bitcast ($int<16>) (kval1*ival1))
        mul_val2 := ($bitcast ($int<16>) (kval2*ival2))
        mul_val3 := ($bitcast ($int<16>) (kval3*ival3))
        acc_val :=  ((acc + mul_val1) + (mul_val2 + mul_val3))
        
        $volatile chl_done := (chl == num_chl)
        $volatile num_done := ((num == 2) & chl_done)
        $volatile col_done := (col == num_col)
        $volatile row_done := (col_done & num_done)
        $volatile out_done_flag := (row == num_row)
        $volatile store_kernel := (~(out_done_flag & col_done))
        $volatile all_done_flag := (out_done_flag & row_done)
        
        $guard (store_kernel) conv_k1 := kread1
        $guard (store_kernel) conv_k2 := kread2
        $guard (store_kernel) conv_k3 := kread3
        
        $volatile n_chl := ($mux chl_done 0 (chl + 1))
        $volatile n_num := ($mux chl_done ($mux num_done 0 (num+1)) num)
        $volatile n_col := ($mux num_done ($mux col_done 0 (col + 1)) col)
        $volatile n_row := ($mux row_done (row+1) row)
        $volatile nacc := ($mux num_done 0 acc_val)
        
        $split (acc_val 8 8) (acc_val_up acc_val_dn)
        $guard (num_done) maxpool_output_pipe := ($bitcast ($uint<8>) acc_val_up)
        $guard (num_done) maxpool_output_pipe := ($bitcast ($uint<8>) acc_val_dn)
        
        $while (~all_done_flag)
        input_done_pipe := 1
        
        $place [loopback]
    }
}
