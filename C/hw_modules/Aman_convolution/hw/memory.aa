//$record [structx_x__SizedTensorCustom] < $array [16384] $of $uint<64> > 
//$storage T:structx_x__SizedTensorCustom
$pipe kernel_pipe1 : $uint<16> $depth 400
$pipe kernel_pipe2 : $uint<16> $depth 400
$pipe input_pipe1 : $uint<16> $depth 400
$pipe size_pipe : $uint<32> $depth 1
$pipe kernel_done_pipe : $uint<1> $depth 1
$pipe input_done_pipe : $uint<8> $depth 1

// Load the kernel channel into the kernel pipes
$module [loadKernelChannel]
$in (start_add end_add : $uint<64> pp : $uint<8>)
$out ()
$is
{   
    sh_start := (start_add>>2)
    pingpong := ($bitcast ($uint<1>) pp)
    fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][sh_start])
    my_fetch := ->(fetch_addr)
    first_fill := (start_add == 0)
    $guard (~first_fill) start_next := input_done_pipe
    $branchblock [load_block]
    {
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi mycount := start_add $on $entry nmycount $on $loopback
        $phi fetch_val := my_fetch $on $entry nfetch_val $on $loopback
        $endmerge
        my_num1 := ((3-(mycount&3))<<4)
        $volatile nmycount := (mycount + 1)
        var_val := ($bitcast ($uint<16>) (fetch_val>>my_num1))
        $guard (~pingpong) kernel_pipe1 := var_val
        $guard (pingpong) kernel_pipe2 := var_val
        fn := ((nmycount& 3) == 0)
        fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(nmycount >>2)])
        $guard (fn) fv := ->(fetch_addr)
        nfetch_val := ($mux fn fv fetch_val)
        $while (mycount < (end_add-1))
    }
    size_pipe := ($concat pingpong ($bitcast ($uint<31>) (end_add - start_add)))
}

// Access the input tensor and write to iput pipe
$module [access_T]
$in(num_cont row1 col1 rk1 chl_in ct: $uint<16> )
$out()
$is
{
    $branchblock [access_block]
    {
        m_factor := ($bitcast ($uint<32>) (ct * chl_in))
        nl_start := num_cont
        fn_blk := ($mux (num_cont < 4) num_cont 4)
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address := ($bitcast ($uint<64>) 0) $on $entry n_address $on $loopback
        $phi word_start := ($bitcast ($uint<2>) 0) $on $entry n_word_start $on $loopback
        $phi num_left := nl_start $on $entry n_left $on $loopback
        $phi num_blk := ($bitcast ($uint<16>) fn_blk) $on $entry n_blk $on $loopback
        $phi winr := ($bitcast ($uint<16>) 0) $on $entry n_winr $on $loopback
        $phi col := ($bitcast ($uint<16>) 0) $on $entry n_col $on $loopback
        $phi row := ($bitcast ($uint<16>) 0) $on $entry n_row $on $loopback
        $endmerge
        c1 := (word_start == 0)
        c2 := (((word_start == 0) & (num_blk > 1)) | (word_start == 1))
        c3 := (((word_start == 0) & (num_blk > 2)) | (((word_start == 1) & (num_blk > 1)) | (word_start == 2)))
        c4 := ((num_blk + ($bitcast ($uint<16>) word_start)) > 3)
        fetch_addr := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][address])
        word_read := ->(fetch_addr)
        $split (word_read 16 16 16 16) (w1 w2 w3 w4)
        $guard (c1) input_pipe1 := w1
        $guard (c2) input_pipe1 := w2
        $guard (c3) input_pipe1 := w3
        $guard (c4) input_pipe1 := w4
        flag1 := (num_left == num_blk)
        $volatile winr_done := (winr == rk1)
        $volatile col_done := (col == col1)
        $volatile n_winr := ($mux flag1 ($mux winr_done 0 (winr+1)) winr)
        $volatile n_col := ($mux (winr_done & flag1) ($mux col_done 0 (col+1)) col)
        $volatile n_row := ($mux (winr_done & (col_done & flag1)) (row+1) row)
        $volatile na1 := ($bitcast ($uint<32>) (chl_in*(n_col+(ct*n_row))))
        $volatile na2 := ($bitcast ($uint<32>) (m_factor*($bitcast ($uint<32>) n_winr)))
        $volatile na3 := (na1 + na2)
        $volatile na4 := ($bitcast ($uint<16>) (na3 & 3))
        $volatile n_word_start := ($mux flag1 ($bitcast ($uint<2>) na4) 0)
        $volatile n_address := ($mux flag1 ($bitcast ($uint<64>) (na3>>2)) (address + 1))
        $volatile n_left := ($mux flag1 nl_start (num_left - num_blk))
        $volatile n_blk := ($mux flag1 ($mux ((fn_blk + na4) > 4) (4 - na4) fn_blk) ($mux (n_left < 4) n_left 4))
        $while (n_row != row1)
    }
}

// Perform convolution operation
$module [convolve]
$in ()
$out ()
$is
{
    $branchblock [conv_block]
    {
        $merge $entry loopback
        $endmerge
        num_out := num_out_pipe
        size_read := size_pipe
        $split (size_read 1 31) (pingpong size)
        $volatile mcount_var := ($bitcast ($uint<31>) 0)
        $volatile acc_var := ($bitcast ($int<16>) 0)
        $dopipeline $depth 15 $buffering 1 $fullrate
        $merge $entry $loopback
        $phi mycount := mcount_var $on $entry nmycount $on $loopback
        $phi acc := acc_var $on $entry nacc $on $loopback
        $phi out_count := ($bitcast ($uint<16>) 1) $on $entry n_out_count $on $loopback
        $endmerge
        iread := input_pipe1
        ival := ($bitcast ($int<16>) iread)
        $guard (~pingpong) temp1 := kernel_pipe1
        $guard (pingpong) temp2 := kernel_pipe2
        kread := ($mux pingpong temp2 temp1)
        kval := ($bitcast ($int<16>) kread)
        mul_val := (kval*ival)
        next_sum := (mycount == (size - 1))
        acc_val :=  (($bitcast ($int<16>) acc) + ($bitcast ($int<16>) mul_val))
        nacc := ($mux next_sum 0 acc_val)
        nmycount := ($mux next_sum 0 (mycount+1))
        out_done_flag := (out_count == num_out)
        send_back1 := ((~out_done_flag) & (~pingpong))
        send_back2 := ((~out_done_flag) & pingpong)
        $guard (send_back1) kernel_pipe1 := kread
        $guard (send_back2) kernel_pipe2 := kread
        n_out_count := ($mux next_sum ($mux out_done_flag ($bitcast ($uint<16>) 1) (out_count + 1)) out_count)
        all_done_flag := (out_done_flag & next_sum)
        //$split (acc_val 8 8) (acc_val_up acc_val_dn)
        //$guard (next_sum) maxpool_output_pipe := ($bitcast ($uint<8>) acc_val_up)
        //$guard (next_sum) maxpool_output_pipe := ($bitcast ($uint<8>) acc_val_dn)
        $guard (next_sum) output_pipe := ($bitcast ($uint<16>) acc_val)
                $while (~all_done_flag)
        input_done_pipe := 1
        $place [loopback]
    }
}
$module [sendModule] $in () $out () $is
{
    $branchblock [sendBlock]{
        rb := output_pipe
        cb := output_pipe
        chl_out := output_pipe
        max_count := ($bitcast ($uint<32>) (rb*cb))

        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address := ($bitcast ($uint<32>) 0) $on $entry n_address $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $phi count := ($bitcast ($uint<32>) 0) $on $entry n_count $on $loopback
        $endmerge
        $volatile chl_change := (count == (max_count - 1))
        $volatile n_chl := ($mux chl_change (chl+1) chl)
        $volatile n_address := ($mux chl_change ($bitcast ($uint<32>) n_chl) (address + ($bitcast ($uint<32>) chl_out)))
        $volatile n_count := ($mux chl_change 0 (count + 1))
        fetch_addr := @(B[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (address >> 2))])
        fetch_val := ->(fetch_addr)
        output_data := output_pipe
        $split (fetch_val 16 16 16 16) (w1 w2 w3 w4)
        $volatile location := ($bitcast ($uint<2>) (address&3))
        wb1 := ($mux (location == 0) output_data w1)
        wb2 := ($mux (location == 1) output_data w2)
        wb3 := ($mux (location == 2) output_data w3)
        wb4 := ($mux (location == 3) output_data w4)
        ->(fetch_addr) := ($concat wb1 wb2 wb3 wb4)
        continue_flag := ((chl < (chl_out - 1)) | (~chl_change))
        $while continue_flag
        input_done_pipe := 1
    }
}