//$record [structx_x__SizedTensorCustom] < $array [16384] $of $uint<64> > 
//$storage T:structx_x__SizedTensorCustom
$pipe kernel_pipe1 : $uint<16> $depth 100
$pipe input_pipe1 : $uint<16> $depth 100
$pipe size_pipe : $uint<32> $depth 1
$pipe kernel_done_pipe : $uint<1> $depth 1
$pipe input_done_pipe : $uint<1> $depth 1

// Load the kernel channel into the kernel pipes
$module [loadKernelChannel]
$in (start_add end_add : $uint<64>)
$out ()
$is
{   
    sh_start := (start_add>>2)
    fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][sh_start])
    my_fetch := ->(fetch_addr)
    first_fill := (start_add == 0)
    $guard (~first_fill) start_next := input_done_pipe
    $branchblock [load_block]
    {
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi mycount := start_add $on $entry nmycount $on $loopback
        $phi fetch_val := my_fetch $on $entry nfetch_val $on $loopback
        $endmerge
        my_num1 := ((3-(mycount&3))<<4)
        $volatile nmycount := (mycount + 1)
        //$guard (~first_fill) empty_pipe_content := kernel_pipe1
        var_val := ($bitcast ($uint<16>) (fetch_val>>my_num1))
        kernel_pipe1 := var_val
        fn := ((nmycount& 3) == 0)
        fetch_addr := @(K[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][(nmycount >>2)])
        $guard (fn) fv := ->(fetch_addr)
        nfetch_val := ($mux fn fv fetch_val)
        $while (mycount < (end_add-1))
    }
    $guard (first_fill) size_pipe := ($bitcast ($uint<32>) (end_add - start_add))
}

// Access the input tensor and write to iput pipe
$module [access_T]
$in(num_cont row1 col1 rk1 chl_in ct: $uint<16> )
$out()
$is
{
    $branchblock [access_block]
    {
        m_factor := ($bitcast ($uint<32>) (ct * chl_in))
        nl_start := num_cont
        fn_blk := ($mux (num_cont < 4) num_cont 4)
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address := ($bitcast ($uint<64>) 0) $on $entry n_address $on $loopback
        $phi word_start := ($bitcast ($uint<2>) 0) $on $entry n_word_start $on $loopback
        $phi num_left := nl_start $on $entry n_left $on $loopback
        $phi num_blk := ($bitcast ($uint<16>) fn_blk) $on $entry n_blk $on $loopback
        $phi winr := ($bitcast ($uint<16>) 0) $on $entry n_winr $on $loopback
        $phi col := ($bitcast ($uint<16>) 0) $on $entry n_col $on $loopback
        $phi row := ($bitcast ($uint<16>) 0) $on $entry n_row $on $loopback
        $endmerge
        c1 := (word_start == 0)
        c2 := (((word_start == 0) & (num_blk > 1)) | (word_start == 1))
        c3 := (((word_start == 0) & (num_blk > 2)) | (((word_start == 1) & (num_blk > 1)) | (word_start == 2)))
        c4 := ((num_blk + ($bitcast ($uint<16>) word_start)) > 3)
        fetch_addr := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][address])
        word_read := ->(fetch_addr)
        $split (word_read 16 16 16 16) (w1 w2 w3 w4)
        $guard (c1) input_pipe1 := w1
        $guard (c2) input_pipe1 := w2
        $guard (c3) input_pipe1 := w3
        $guard (c4) input_pipe1 := w4
        flag1 := (num_left == num_blk)
        $volatile winr_done := (winr == rk1)
        $volatile col_done := (col == col1)
        $volatile n_winr := ($mux flag1 ($mux winr_done 0 (winr+1)) winr)
        $volatile n_col := ($mux (winr_done & flag1) ($mux col_done 0 (col+1)) col)
        $volatile n_row := ($mux (winr_done & (col_done & flag1)) (row+1) row)
        $volatile na1 := ($bitcast ($uint<32>) (chl_in*(n_col+(ct*n_row))))
        $volatile na2 := ($bitcast ($uint<32>) (m_factor*($bitcast ($uint<32>) n_winr)))
        $volatile na3 := (na1 + na2)
        $volatile na4 := ($bitcast ($uint<16>) (na3 & 3))
        $volatile n_word_start := ($mux flag1 ($bitcast ($uint<2>) na4) 0)
        $volatile n_address := ($mux flag1 ($bitcast ($uint<64>) (na3>>2)) (address + 1))
        $volatile n_left := ($mux flag1 nl_start (num_left - num_blk))
        $volatile n_blk := ($mux flag1 ($mux ((fn_blk + na4) > 4) (4 - na4) fn_blk) ($mux (n_left < 4) n_left 4))
        $while (n_row != row1)
    }
}

// Perform convolution operation
$module [convolve]
$in ()
$out ()
$is
{
    $branchblock [conv_block]
    {
        num_out := num_out_pipe
        size := size_pipe
        $volatile mcount_var := ($bitcast ($uint<32>) 0)
        $volatile acc_var := ($bitcast ($int<32>) 0)
        $dopipeline $depth 15 $buffering 1 $fullrate
        $merge $entry $loopback
        $phi mycount := mcount_var $on $entry nmycount $on $loopback
        $phi acc := acc_var $on $entry nacc $on $loopback
        $phi out_count := ($bitcast ($uint<16>) 1) $on $entry n_out_count $on $loopback
        $endmerge
        iread := input_pipe1
        ival := ($bitcast ($int<16>) iread)
        kread := kernel_pipe1
        kval := ($bitcast ($int<16>) kread)
        mul_val := (kval*ival)
        next_sum := (mycount == (size - 1))
        acc_val :=  (($bitcast ($int<32>) acc) + ($bitcast ($int<32>) mul_val))
        nacc := ($mux next_sum 0 acc_val)
        nmycount := ($mux next_sum 0 (mycount+1))
        out_done_flag := (out_count == num_out)
        $guard (~out_done_flag) kernel_pipe1 := kread
        n_out_count := ($mux next_sum ($mux out_done_flag ($bitcast ($uint<16>) 1) (out_count + 1)) out_count)
        all_done_flag := (out_done_flag & next_sum)
        $guard (all_done_flag) input_done_pipe := 1
        $guard (next_sum) maxpool_output_pipe := ($bitcast ($uint<16>) acc_val)
        $while 1
    }
}
