$parameter PIPE_WIDTH 64
$parameter INTERMEDIATE_PIPE_DEPTH 64
$parameter IP_DEPTH 512
$parameter K_DEPTH 512
$pipe kernel_pipe1 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe kernel_pipe2 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe kernel_pipe3 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$parameter N_ROWS_S 2
$pipe input_pipe1 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe input_pipe2 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe input_pipe3 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe input_pipe4 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
//$pipe input_pipe5 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
//$pipe input_pipe6 : $uint<PIPE_WIDTH> $depth INTERMEDIATE_PIPE_DEPTH
$pipe size_pipe : $uint<16> $depth 4
$pipe input_done_pipe : $uint<8> $depth 1

// Load the kernel channel into the kernel pipes
$module [loadKernel]
$in ()
$out ()
$is
{  
    
    $branchblock [load_block]
    { 
        chl_in := kernel_module_pipe
        chl_out := kernel_module_pipe 
        row_size := (chl_in + (chl_in << 1))
        
        $merge $entry loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on loopback
        $phi start_add := ($bitcast ($uint<32>) 0) $on $entry n_start_add $on loopback
        $endmerge

        ea := ((start_add + ( $bitcast ($uint<32> ) row_size)) - 1)

            $dopipeline $depth 15 $buffering 2 $fullrate
            $merge $entry $loopback
            $phi mycount := start_add $on $entry nmycount $on $loopback
            $endmerge
    
            $volatile nmycount := (mycount + 1)
            fetch_addr1 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) mycount)])
            fetch_addr2 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (mycount+ ( $bitcast ($uint<32> ) row_size)))])
            fetch_addr3 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (mycount+ ( $bitcast ($uint<32> )(row_size<<1))))])
            kernel_pipe1 := ->(fetch_addr1)
            kernel_pipe2 := ->(fetch_addr2)
            kernel_pipe3 := ->(fetch_addr3)
        
            $while (mycount < ea)

        n_chl_num := (chl_num + 1)
        n_start_add := (start_add + (9*($bitcast ($uint<32>) chl_in)))
        size_pipe := chl_in
        $if (n_chl_num != chl_out) $then $place [loopback] $endif
    }
}

// Access the input tensor and write to iput pipe
$module [access_T]
$in()
$out()
$is
{
    $branchblock [access_block]
    {
        row_in := input_module_pipe
        ct := input_module_pipe
        chl_in := input_module_pipe
        chl_out := input_module_pipe

        m_factor := ($bitcast ($uint<32>) (ct * chl_in))
        m2_factor := (m_factor << 1) 

        $merge $entry loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on loopback
        $endmerge
        
            // Pipeline for sending inputs
            $dopipeline $depth 15 $buffering 2 $fullrate
            $merge $entry $loopback
            $phi address1 := ($bitcast ($uint<32>) 0) $on $entry n_address1 $on $loopback
            $phi row1 := ($bitcast ($uint<16>) 0) $on $entry n_row1 $on $loopback
            $phi address2 := ($bitcast ($uint<32>) m_factor) $on $entry n_address2 $on $loopback
            $phi row2 := ($bitcast ($uint<16>) 0) $on $entry n_row2 $on $loopback
            $phi address3 := ($bitcast ($uint<32>) m2_factor) $on $entry n_address3 $on $loopback
            $phi row3 := ($bitcast ($uint<16>) 0) $on $entry n_row3 $on $loopback
            $phi address4 := ($bitcast ($uint<32>) (m_factor+m2_factor)) $on $entry n_address4 $on $loopback
            $phi row4 := ($bitcast ($uint<16>) 1) $on $entry n_row4 $on $loopback
            //$phi address5 := ($bitcast ($uint<32>) (m2_factor+m2_factor)) $on $entry n_address5 $on $loopback
            //$phi row5 := ($bitcast ($uint<16>) 2) $on $entry n_row5 $on $loopback
            //$phi address6 := ($bitcast ($uint<32>) ((m_factor+m2_factor)+m2_factor)) $on $entry n_address6 $on $loopback
            //$phi row6 := ($bitcast ($uint<16>) 3) $on $entry n_row6 $on $loopback
            $phi start := ($bitcast ($uint<1>) 1) $on $entry n_start $on $loopback
            $phi mycounter := ($bitcast ($uint<32>) m_factor) $on $entry n_mycounter $on $loopback
            $endmerge
            
            $volatile next_row := (mycounter == 1)
            $volatile n_start := next_row
            $volatile tmp_cnt := (mycounter - 1)
            $volatile n_mycounter := ($mux next_row m_factor tmp_cnt )

            #define num 1
            #include macro_file1.aa
            #define num 2
            #include macro_file1.aa
            #define num 3
            #include macro_file1.aa
            #define num 4
            #include macro_file1.aa
            // # define num 5
            // # include macro_file1.aa
            // # define num 6
            // # include macro_file1.aa

            $volatile continue_flag1 := (n_row1 < row_in)

            $while continue_flag1

        //mapool_output_pipe := ($bitcast ($uint<8>) 50)
        n_chl_num := (chl_num + 1)
        $if (n_chl_num != chl_out) $then $place [loopback] $endif
    }
}

// Perform convolution operation
$module [convolve]
$in ()
$out ()
$is
{
    $pipe conv_ip1 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip2 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip3 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip4 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    //$pipe conv_ip5 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    //$pipe conv_ip6 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_k1 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $pipe conv_k2 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $pipe conv_k3 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $branchblock [conv_block]
    {
        num_row := (num_out_pipe - 1)
        num_col := (num_out_pipe - 1)
        
        $merge $entry loopback
        $endmerge

        chl_in := (size_pipe - 1)
        
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi acc1 := ($bitcast ($int<8>) 0) $on $entry nacc1 $on $loopback
        $phi acc2 := ($bitcast ($int<8>) 0) $on $entry nacc2 $on $loopback
        //$phi acc3 := ($bitcast ($int<8>) 0) $on $entry nacc3 $on $loopback
        //$phi acc4 := ($bitcast ($int<8>) 0) $on $entry nacc4 $on $loopback
        $phi row := ($bitcast ($uint<16>) 0) $on $entry n_row $on $loopback
        $phi col := ($bitcast ($uint<16>) 0) $on $entry n_col $on $loopback
        $phi num := ($bitcast ($uint<2>) 0) $on $entry n_num $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $endmerge

        $volatile read_ip := ((col == 0) | (num == 2))
        $volatile write_input := ((col < num_col) & (num > 0))
        $volatile read_k := ((col == 0) & (row == 0))
        
        #define num 1
        #include macro_file2.aa
        #define num 2
        #include macro_file2.aa
        #define num 3
        #include macro_file2.aa
        #define num 4
        #include macro_file2.aa
        // # define num 5
        // # include macro_file2.aa
        // # define num 6
        // # include macro_file2.aa

        #define k_num 1        
        #include macro_file4.aa

        #define mul_num 1
        #define in_num 1
        #include macro_file3.aa        
        #define mul_num 4
        #define in_num 2
        #include macro_file3.aa
        // # define mul_num 7
        // # define in_num 3
        // # include macro_file3.aa
        // # define mul_num 10
        // # define in_num 4
        // # include macro_file3.aa

        #define k_num 2
        #include macro_file4.aa
        
        #define mul_num 2
        #define in_num 2
        #include macro_file3.aa
        #define mul_num 5
        #define in_num 3
        #include macro_file3.aa
        // # define mul_num 8
        // # define in_num 4
        // # include macro_file3.aa
        // # define mul_num 11
        // # define in_num 5
        // # include macro_file3.aa

        #define k_num 3
        #include macro_file4.aa

        #define mul_num 3
        #define in_num 3
        #include macro_file3.aa
        #define mul_num 6
        #define in_num 4
        #include macro_file3.aa
        // # define mul_num 9
        // # define in_num 5
        // # include macro_file3.aa
        // # define mul_num 12
        // # define in_num 6
        // # include macro_file3.aa

        acc_val1 :=  ((acc1 + t_acc_val1) + (t_acc_val2 + t_acc_val3))
        acc_val2 :=  ((acc2 + t_acc_val4) + (t_acc_val5 + t_acc_val6))
        //acc_val3 :=  ((acc3 + t_acc_val7) + (t_acc_val8 + t_acc_val9))
        //acc_val4 :=  ((acc4 + t_acc_val10) + (t_acc_val11 + t_acc_val12))
        
        $volatile chl_done := (chl == chl_in)
        $volatile num_done := ((num == 2) & chl_done)
        $volatile col_done := (col == num_col)
        $volatile row_done := (col_done & num_done)
        $volatile out_done_flag := (row >= (num_row - 1))
        $volatile store_kernel := (~(out_done_flag & col_done))
        $volatile all_done_flag := (out_done_flag & row_done)
        
        $guard (store_kernel) conv_k1 := kread1
        $guard (store_kernel) conv_k2 := kread2
        $guard (store_kernel) conv_k3 := kread3
        
        $volatile n_chl := ($mux chl_done 0 (chl + 1))
        $volatile n_num := ($mux chl_done ($mux num_done 0 (num+1)) num)
        $volatile n_col := ($mux num_done ($mux col_done 0 (col + 1)) col)
        $volatile n_row := ($mux row_done (row+N_ROWS_S) row)
        $volatile nacc1 := ($mux num_done 0 acc_val1)
        $volatile nacc2 := ($mux num_done 0 acc_val2)
        //$volatile nacc3 := ($mux num_done 0 acc_val3)
        //$volatile nacc4 := ($mux num_done 0 acc_val4)
        
        //send_val := ($mux (acc_val < 0) 0 acc_val)
        $guard (num_done) output_pipe := ($concat ($bitcast ($uint<8>) acc_val1) ($bitcast ($uint<8>) acc_val2))
        //$guard (num_done) output_pipe := ($concat ($bitcast ($uint<8>) acc_val3) ($bitcast ($uint<8>) acc_val4))
        $while (~all_done_flag)
        //mapool_output_pipe := 5
        
        $place [loopback]
    }
}


$module [sendModule] $in () $out () $is
{
    $branchblock [sendBlock]{
        rb := output_pipe
        cb := output_pipe
        chl_out := output_pipe
        max_count := ($bitcast ($uint<32>) (rb*cb))
        row_size := ($bitcast ($uint<32>) (chl_out*cb))

        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address1 := ($bitcast ($uint<32>) 0) $on $entry n_address1 $on $loopback
        $phi address2 := ($bitcast ($uint<32>) row_size) $on $entry n_address2 $on $loopback
        //$phi address3 := ($bitcast ($uint<32>) (row_size<<1)) $on $entry n_address3 $on $loopback
        //$phi address4 := ($bitcast ($uint<32>) ((row_size << 1) +row_size)) $on $entry n_address4 $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $phi col := ($bitcast ($uint<16>) 1) $on $entry n_col $on $loopback
        $phi row := ($bitcast ($uint<16>) 1) $on $entry n_row $on $loopback
        $endmerge

        $volatile row_change := (col == cb)

        // Check this later - odd values of row will be incorrect
        $volatile chl_change := (row_change & (row >= (rb - 1)))
        $volatile n_col := ($mux row_change 1 (col + 1))
        $volatile n_row := ($mux chl_change 1 ($mux row_change (row + N_ROWS_S) row))
        $volatile n_chl := ($mux chl_change (chl+1) chl)
        
        $volatile tmp1 := (address1 + ($bitcast ($uint<32>) chl_out))
        $volatile tmp2 := (address2 + ($bitcast ($uint<32>) chl_out))
        //$volatile tmp3 := (address3 + ($bitcast ($uint<32>) chl_out))
        //$volatile tmp4 := (address4 + ($bitcast ($uint<32>) chl_out))
        $volatile n_address1 := ($mux chl_change ($bitcast ($uint<32>) n_chl) ($mux row_change (tmp1+row_size) tmp1))
        $volatile n_address2 := ($mux chl_change (($bitcast ($uint<32>) n_chl)+row_size) ($mux row_change (tmp2+row_size) tmp2))
        //$volatile n_address3 := ($mux chl_change (($bitcast ($uint<32>) n_chl)+(row_size<<1)) ($mux row_change (tmp3+row_size) tmp3))
        //$volatile n_address4 := ($mux chl_change (($bitcast ($uint<32>) n_chl)+((row_size << 1) +row_size)) ($mux row_change (tmp4+row_size) tmp4))
        
        fetch_addr1 := @(B[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (address1 >> 3))])
        fetch_addr2 := @(B[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (address2 >> 3))])
        //fetch_addr3 := @(B[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (address3 >> 3))])
        //fetch_addr4 := @(B[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (address4 >> 3))])
        fetch_val1 := ->(fetch_addr1)
        fetch_val2 := ->(fetch_addr2)
        //fetch_val3 := ->(fetch_addr3)
        //fetch_val4 := ->(fetch_addr4)
        output_data_read1 := output_pipe
        //output_data_read2 := output_pipe
        $split (output_data_read1 8 8) (output_data1 output_data2)
        //$split (output_data_read2 8 8) (output_data3 output_data4)

        $split (fetch_val1 8 8 8 8 8 8 8 8) (w11 w12 w13 w14 w15 w16 w17 w18)
        $split (fetch_val2 8 8 8 8 8 8 8 8) (w21 w22 w23 w24 w25 w26 w27 w28)
        //$split (fetch_val3 8 8 8 8 8 8 8 8) (w31 w32 w33 w34 w35 w36 w37 w38)
        //$split (fetch_val4 8 8 8 8 8 8 8 8) (w41 w42 w43 w44 w45 w46 w47 w48)
        $volatile location1 := ($bitcast ($uint<3>) address1)
        $volatile location2 := ($bitcast ($uint<3>) address2)
        //$volatile location3 := ($bitcast ($uint<3>) address3)
        //$volatile location4 := ($bitcast ($uint<3>) address4)
        wb11 := ($mux (location1 == 0) output_data1 w11)
        wb12 := ($mux (location1 == 1) output_data1 w12)
        wb13 := ($mux (location1 == 2) output_data1 w13)
        wb14 := ($mux (location1 == 3) output_data1 w14)
        wb15 := ($mux (location1 == 4) output_data1 w15)
        wb16 := ($mux (location1 == 5) output_data1 w16)
        wb17 := ($mux (location1 == 6) output_data1 w17)
        wb18 := ($mux (location1 == 7) output_data1 w18)
        wb21 := ($mux (location2 == 0) output_data2 w21)
        wb22 := ($mux (location2 == 1) output_data2 w22)
        wb23 := ($mux (location2 == 2) output_data2 w23)
        wb24 := ($mux (location2 == 3) output_data2 w24)
        wb25 := ($mux (location2 == 4) output_data2 w25)
        wb26 := ($mux (location2 == 5) output_data2 w26)
        wb27 := ($mux (location2 == 6) output_data2 w27)
        wb28 := ($mux (location2 == 7) output_data2 w28)
        //wb31 := ($mux (location3 == 0) output_data3 w31)
        //wb32 := ($mux (location3 == 1) output_data3 w32)
        //wb33 := ($mux (location3 == 2) output_data3 w33)
        //wb34 := ($mux (location3 == 3) output_data3 w34)
        //wb35 := ($mux (location3 == 4) output_data3 w35)
        //wb36 := ($mux (location3 == 5) output_data3 w36)
        //wb37 := ($mux (location3 == 6) output_data3 w37)
        //wb38 := ($mux (location3 == 7) output_data3 w38)
        //wb41 := ($mux (location4 == 0) output_data4 w41)
        //wb42 := ($mux (location4 == 1) output_data4 w42)
        //wb43 := ($mux (location4 == 2) output_data4 w43)
        //wb44 := ($mux (location4 == 3) output_data4 w44)
        //wb45 := ($mux (location4 == 4) output_data4 w45)
        //wb46 := ($mux (location4 == 5) output_data4 w46)
        //wb47 := ($mux (location4 == 6) output_data4 w47)
        //wb48 := ($mux (location4 == 7) output_data4 w48)
        ->(fetch_addr1) := ($concat wb11 wb12 wb13 wb14 wb15 wb16 wb17 wb18)
        ->(fetch_addr2) := ($concat wb21 wb22 wb23 wb24 wb25 wb26 wb27 wb28)
        //->(fetch_addr3) := ($concat wb31 wb32 wb33 wb34 wb35 wb36 wb37 wb38)
        //>(fetch_addr4) := ($concat wb41 wb42 wb43 wb44 wb45 wb46 wb47 wb48)
        continue_flag := ((chl < (chl_out - 1)) | (~chl_change))
        //mapool_output_pipe := 100
        $while continue_flag
        input_done_pipe := 1
    }
}