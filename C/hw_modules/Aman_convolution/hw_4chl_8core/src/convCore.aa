// Perform convolution operation
$module [convolveCore##core_num ]
$in ()
$out ()
$is
{
    $pipe conv_ip1 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip2 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip3 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip4 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip5 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_ip6 : $uint<PIPE_WIDTH> $depth IP_DEPTH
    $pipe conv_k1 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $pipe conv_k2 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $pipe conv_k3 : $uint<PIPE_WIDTH> $depth K_DEPTH
    $branchblock [conv_block]
    {
        num_row := (num_out_pipe##core_num - 1)
        num_col := (num_out_pipe##core_num - 1)
        
        $merge $entry loopback
        $endmerge

        chl_in := (size_pipe##core_num - 1)
        
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi acc1 := ($bitcast ($int<8>) 0) $on $entry nacc1 $on $loopback
        $phi acc2 := ($bitcast ($int<8>) 0) $on $entry nacc2 $on $loopback
        $phi acc3 := ($bitcast ($int<8>) 0) $on $entry nacc3 $on $loopback
        $phi acc4 := ($bitcast ($int<8>) 0) $on $entry nacc4 $on $loopback
        $phi row := ($bitcast ($uint<16>) 0) $on $entry n_row $on $loopback
        $phi col := ($bitcast ($uint<16>) 0) $on $entry n_col $on $loopback
        $phi num := ($bitcast ($uint<2>) 0) $on $entry n_num $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $endmerge

        $volatile read_ip := ((col == 0) | (num == 2))
        $volatile write_input := ((col < num_col) & (num > 0))
        $volatile read_k := ((col == 0) & (row == 0))
        
        #define num 1
        #include macro_file2.aa
        #define num 2
        #include macro_file2.aa
        #define num 3
        #include macro_file2.aa
        #define num 4
        #include macro_file2.aa
        #define num 5
        #include macro_file2.aa
        #define num 6
        #include macro_file2.aa

        #define k_num 1        
        #include macro_file4.aa

        #define mul_num 1
        #define in_num 1
        #include macro_file3.aa        
        #define mul_num 4
        #define in_num 2
        #include macro_file3.aa
        #define mul_num 7
        #define in_num 3
        #include macro_file3.aa
        #define mul_num 10
        #define in_num 4
        #include macro_file3.aa

        #define k_num 2
        #include macro_file4.aa
        
        #define mul_num 2
        #define in_num 2
        #include macro_file3.aa
        #define mul_num 5
        #define in_num 3
        #include macro_file3.aa
        #define mul_num 8
        #define in_num 4
        #include macro_file3.aa
        #define mul_num 11
        #define in_num 5
        #include macro_file3.aa

        #define k_num 3
        #include macro_file4.aa

        #define mul_num 3
        #define in_num 3
        #include macro_file3.aa
        #define mul_num 6
        #define in_num 4
        #include macro_file3.aa
        #define mul_num 9
        #define in_num 5
        #include macro_file3.aa
        #define mul_num 12
        #define in_num 6
        #include macro_file3.aa

        acc_val1 :=  ((acc1 + t_acc_val1) + (t_acc_val2 + t_acc_val3))
        acc_val2 :=  ((acc2 + t_acc_val4) + (t_acc_val5 + t_acc_val6))
        acc_val3 :=  ((acc3 + t_acc_val7) + (t_acc_val8 + t_acc_val9))
        acc_val4 :=  ((acc4 + t_acc_val10) + (t_acc_val11 + t_acc_val12))
        
        $volatile chl_done := (chl == chl_in)
        $volatile num_done := ((num == 2) & chl_done)
        $volatile col_done := (col == num_col)
        $volatile row_done := (col_done & num_done)
        $volatile out_done_flag := (row >= (num_row - 3))
        $volatile store_kernel := (~(out_done_flag & col_done))
        $volatile all_done_flag := (out_done_flag & row_done)
        
        $guard (store_kernel) conv_k1 := kread1
        $guard (store_kernel) conv_k2 := kread2
        $guard (store_kernel) conv_k3 := kread3
        
        $volatile n_chl := ($mux chl_done 0 (chl + 1))
        $volatile n_num := ($mux chl_done ($mux num_done 0 (num+1)) num)
        $volatile n_col := ($mux num_done ($mux col_done 0 (col + 1)) col)
        $volatile n_row := ($mux row_done (row+N_ROWS_S) row)
        $volatile nacc1 := ($mux num_done 0 acc_val1)
        $volatile nacc2 := ($mux num_done 0 acc_val2)
        $volatile nacc3 := ($mux num_done 0 acc_val3)
        $volatile nacc4 := ($mux num_done 0 acc_val4)
        
        //send_val := ($mux (acc_val < 0) 0 acc_val)
        $guard (num_done) output_pipe1_##core_num := ($concat ($bitcast ($uint<8>) acc_val1) ($bitcast ($uint<8>) acc_val2))
        $guard (num_done) output_pipe2_##core_num := ($concat ($bitcast ($uint<8>) acc_val3) ($bitcast ($uint<8>) acc_val4))
        $while (~all_done_flag)
        //maxpool_output_pipe := 5
        
        $place [loopback]
    }
}
