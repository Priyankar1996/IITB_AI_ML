// Access the input tensor and write to iput pipe
$module [access_T]
$in()
$out()
$is
{
    $branchblock [access_block]
    {
        row_in := input_module_pipe
        ct := input_module_pipe
        chl_in := input_module_pipe
        chl_out := input_module_pipe

        m_factor := ($bitcast ($uint<32>) (ct * chl_in))
        m2_factor := (m_factor << 1)
        m3_factor := (m2_factor+m_factor)
        m4_factor := (m_factor << 2)

        $merge $entry loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on loopback
        $endmerge
        
            // Pipeline for sending inputs
            $dopipeline $depth 15 $buffering 2 $fullrate
            $merge $entry $loopback
            $phi address := ($bitcast ($uint<32>) 0) $on $entry n_address $on $loopback
            $phi row1 := ($bitcast ($uint<16>) 0) $on $entry n_row1 $on $loopback

            $phi mycounter := ($bitcast ($uint<32>) m_factor) $on $entry n_mycounter $on $loopback
            $phi row_count := ($bitcast ($uint<2>) 0) $on $entry n_rowcount $on $loopback
            $endmerge
            
            //$call timer (4) (time_pipe)
            //$volatile nxt_cnt := (row_count == 3)
            $volatile next_row :=  (mycounter == 1)
            $volatile tmp_cnt := (mycounter - 1)
            $volatile n_mycounter := ($mux next_row m_factor tmp_cnt ) 
            $volatile n_rowcount := (row_count + 1)
            
            $volatile n_row1 := ($mux next_row (row1 + N_ROWS_S) row1 )
            $volatile n_address := ((address + 1) + ($mux next_row m_factor  0))
            $volatile send_flag1 := (row1 < row_in)
            $volatile send_flag2 := (row1 < (row_in-1))
            ptr1 := @(T[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<32>) 0)][address])
            ptr2 := @(T[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<32>) 0)][(address+($bitcast ($uint<32>) m_factor) )])
            ptr3 := @(T[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<32>) 0)][(address+($bitcast ($uint<32>) m2_factor) )])
            ptr4 := @(T[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<32>) 0)][(address+($bitcast ($uint<32>) m3_factor) )])
            
            $guard (send_flag1 ) core_ip1 := ->(ptr1)
            $guard (send_flag1 ) core_ip2 := ->(ptr2)
            $guard (send_flag1 ) core_ip3 := ->(ptr3)
            $guard (send_flag2 ) core_ip4 := ->(ptr4)

            $volatile continue_flag1 := (n_row1 < row_in)

            $while continue_flag1

        n_chl_num := (chl_num + 1)
        //maxpool_output_pipe := 126
        $if (n_chl_num != chl_out) $then $place [loopback] $endif
    }
}
