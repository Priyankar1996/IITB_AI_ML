// Load the kernel channel into the kernel pipes
$module [loadKernel]
$in ()
$out ()
$is
{  
    
    $branchblock [load_block]
    { 
        chl_in := kernel_module_pipe
        chl_out := (kernel_module_pipe << 3)
        row_size := (chl_in + (chl_in << 1))

        $merge $entry loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on loopback
        $phi start_add := ($bitcast ($uint<32>) 0) $on $entry n_start_add $on loopback
        $endmerge

        ea := ((start_add + ( $bitcast ($uint<32> ) row_size)) - 1)

        $volatile last3 := ($bitcast ($uint<3>) chl_num)
        $volatile last3_0 := (last3 == 0)
        $volatile last3_1 := (last3 == 1)
        $volatile last3_2 := (last3 == 2)
        $volatile last3_3 := (last3 == 3)
        $volatile last3_4 := (last3 == 4)
        $volatile last3_5 := (last3 == 5)
        $volatile last3_6 := (last3 == 6)
        $volatile last3_7 := (last3 == 7)
       
            $dopipeline $depth 15 $buffering 2 $fullrate
            $merge $entry $loopback
            $phi mycount := start_add $on $entry nmycount $on $loopback
            $endmerge
    
            $volatile nmycount := (mycount + 1)
            fetch_addr1 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) mycount)])
            fetch_addr2 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (mycount+ ( $bitcast ($uint<32> ) row_size)))])
            fetch_addr3 := @(K[( $bitcast ($uint<32> ) 0 ) ][($bitcast ($uint<64>) (mycount+ ( $bitcast ($uint<32> )(row_size<<1))))])
            fetch_val1 := ->(fetch_addr1)
            fetch_val2 := ->(fetch_addr2)
            fetch_val3 := ->(fetch_addr3)

            $guard (last3_0) $call writeToPipe1 (fetch_val1 fetch_val2 fetch_val3) (a1)
            $guard (last3_1) $call writeToPipe2 (fetch_val1 fetch_val2 fetch_val3) (a2)
            $guard (last3_2) $call writeToPipe3 (fetch_val1 fetch_val2 fetch_val3) (a3)
            $guard (last3_3) $call writeToPipe4 (fetch_val1 fetch_val2 fetch_val3) (a4)
            $guard (last3_4) $call writeToPipe5 (fetch_val1 fetch_val2 fetch_val3) (a5)
            $guard (last3_5) $call writeToPipe6 (fetch_val1 fetch_val2 fetch_val3) (a6)
            $guard (last3_6) $call writeToPipe7 (fetch_val1 fetch_val2 fetch_val3) (a7)
            $guard (last3_7) $call writeToPipe8 (fetch_val1 fetch_val2 fetch_val3) (a8)
            

            $while (mycount < ea)

        n_chl_num := (chl_num + 1)
        n_start_add := (start_add + (9*($bitcast ($uint<32>) chl_in)))
        $guard (last3_0) $call writeToSizePipe1 (chl_in) (b1)
        $guard (last3_1) $call writeToSizePipe2 (chl_in) (b2)
        $guard (last3_2) $call writeToSizePipe3 (chl_in) (b3)
        $guard (last3_3) $call writeToSizePipe4 (chl_in) (b4)
        $guard (last3_4) $call writeToSizePipe5 (chl_in) (b5)
        $guard (last3_5) $call writeToSizePipe6 (chl_in) (b6)
        $guard (last3_6) $call writeToSizePipe7 (chl_in) (b7)
        $guard (last3_7) $call writeToSizePipe8 (chl_in) (b8)
        //maxpool_output_pipe := 127

        $if (n_chl_num != chl_out) $then $place [loopback] $endif
    }
}

#define num 1
#include writePipes.aa
#define num 2
#include writePipes.aa
#define num 3
#include writePipes.aa
#define num 4
#include writePipes.aa
#define num 5
#include writePipes.aa
#define num 6
#include writePipes.aa
#define num 7
#include writePipes.aa
#define num 8
#include writePipes.aa
