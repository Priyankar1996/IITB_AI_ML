// Load the kernel channel into the kernel pipes
$module [loadKernel]
$in ()
$out ()
$is
{  
    
    $branchblock [load_block]
    { 
        chl_in := kernel_module_pipe
        chl_out := kernel_module_pipe
        index := ($bitcast ($uint<8>) kernel_module_pipe)

        row_size := (chl_in + (chl_in << 1))
        row2_size := (row_size << 1)
        row3_size := ($bitcast ($uint<32> ) (row_size + (row_size << 1)))
        row3_size2 := (row3_size << 1)
        row3_size3 := (row3_size + row3_size2)
        row3_size4 := (row3_size << 2)
        row3_size5 := (row3_size4 + row3_size)
        row3_size6 := (row3_size4 + row3_size2)
        row3_size7 := (row3_size4 + row3_size3)
        
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on $loopback
        $phi ea := (row3_size - 1) $on $entry n_ea $on $loopback
        $phi mycount := ($bitcast ($uint<32>) 0) $on $entry nmycount $on $loopback
        $phi ind := ($bitcast ($uint<2>) 1) $on $entry n_ind $on $loopback
        $endmerge

        $volatile next_row := (ind == 3)
        $volatile nxt_chl := ( (mycount == ea) & next_row)
        $volatile nmycount := (mycount + ($mux next_row (1 + ($mux nxt_chl row3_size 0)) 0))
        $volatile n_chl_num := ($mux nxt_chl (chl_num + 1) chl_num)
        $volatile n_ea := (ea + ($mux nxt_chl (row3_size<<3) 0))
        $volatile n_ind := ($mux next_row 1 (ind + 1))
        $volatile add_val := ($bitcast ($uint<32> )($excmux (ind == 2) row_size (ind == 3) row2_size))
        //$call timer (3) (time_pipe)
        
        ptr1 := @(K[($bitcast ($uint<32>) 0)][(mycount+add_val)])
        fetch_val1 := ->(ptr1)
        ptr2 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size)])
        fetch_val2 := ->(ptr2)
        ptr3 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size2)])
        fetch_val3 := ->(ptr3)
        ptr4 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size3)])
        fetch_val4 := ->(ptr4)
        ptr5 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size4)])
        fetch_val5 := ->(ptr5)
        ptr6 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size5)])
        fetch_val6 := ->(ptr6)
        ptr7 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size6)])
        fetch_val7 := ->(ptr7)
        ptr8 := @(K[($bitcast ($uint<32>) 0)][((mycount+add_val)+row3_size7)])
        fetch_val8 := ->(ptr8)

        $call writeToPipe1 (ind fetch_val1) (a1)
        $call writeToPipe2 (ind fetch_val2) (a2)
        $call writeToPipe3 (ind fetch_val3) (a3)
        $call writeToPipe4 (ind fetch_val4) (a4)
        $call writeToPipe5 (ind fetch_val5) (a5)
        $call writeToPipe6 (ind fetch_val6) (a6)
        $call writeToPipe7 (ind fetch_val7) (a7)
        $call writeToPipe8 (ind fetch_val8) (a8)


        $volatile exit_cond := (nxt_chl & (chl_num == (chl_out-1)))
        $while (~exit_cond)
    }
}

#define num 1
#include writePipes.aa
#define num 2
#include writePipes.aa
#define num 3
#include writePipes.aa
#define num 4
#include writePipes.aa
#define num 5
#include writePipes.aa
#define num 6
#include writePipes.aa
#define num 7
#include writePipes.aa
#define num 8
#include writePipes.aa
