// Load the kernel channel into the kernel pipes
$module [loadKernel]
$in ()
$out ()
$is
{  
    
    $branchblock [load_block]
    { 
        
        $merge $entry reentry
        $endmerge
        
        chl_in := kernel_module_pipe
        chl_out := kernel_module_pipe
        row_size := (chl_in + (chl_in << 1))
        row3_size := ($bitcast ($uint<32> ) (row_size + (row_size << 1)))
        row3_size2 := (row3_size << 1)
        row3_size3 := (row3_size + row3_size2)
        row3_size4 := (row3_size << 2)
        row3_size5 := (row3_size4 + row3_size)
        row3_size6 := (row3_size4 + row3_size2)
        row3_size7 := (row3_size4 + row3_size3)
        index := ($bitcast ($uint<8>) kernel_module_pipe)
        
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on $loopback
        $phi ea := (row3_size - 1) $on $entry n_ea $on $loopback
        $phi mycount := ($bitcast ($uint<32>) 0) $on $entry nmycount $on $loopback
        $phi ind := ($bitcast ($uint<2>) 1) $on $entry n_ind $on $loopback
        $endmerge

        nxt_chl := (mycount == ea)
        $volatile nmycount := ((mycount + 1) + ($mux nxt_chl row3_size 0))
        //$call timer (3) (time_pipe)
        
        ptr1 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][mycount])
        fetch_val1 := ->(ptr1)
        ptr2 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size)])
        fetch_val2 := ->(ptr2)
        ptr3 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size2)])
        fetch_val3 := ->(ptr3)
        ptr4 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size3)])
        fetch_val4 := ->(ptr4)
        ptr5 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size4)])
        fetch_val5 := ->(ptr5)
        ptr6 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size5)])
        fetch_val6 := ->(ptr6)
        ptr7 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size6)])
        fetch_val7 := ->(ptr7)
        ptr8 := @(T[( $bitcast ($uint<32> ) index ) ][($bitcast ($uint<32>) 0)][(mycount+row3_size7)])
        fetch_val8 := ->(ptr8)

        $call writeToPipe1 (ind fetch_val1) (a1)
        $call writeToPipe2 (ind fetch_val2) (a2)
        $call writeToPipe3 (ind fetch_val3) (a3)
        $call writeToPipe4 (ind fetch_val4) (a4)
        $call writeToPipe5 (ind fetch_val5) (a5)
        $call writeToPipe6 (ind fetch_val6) (a6)
        $call writeToPipe7 (ind fetch_val7) (a7)
        $call writeToPipe8 (ind fetch_val8) (a8)

        $volatile n_chl_num := ($mux nxt_chl (chl_num + 1) chl_num)
        $volatile n_ea := (ea + ($mux nxt_chl (row3_size<<3) 0))
        $volatile n_ind := ($mux (ind == 3) 1 (ind + 1))

        $volatile exit_cond := (nxt_chl & (chl_num == (chl_out-1)))
        $while (~exit_cond)
        
        $place [reentry]
    }
}

#define num 1
#include writePipes.aa
#define num 2
#include writePipes.aa
#define num 3
#include writePipes.aa
#define num 4
#include writePipes.aa
#define num 5
#include writePipes.aa
#define num 6
#include writePipes.aa
#define num 7
#include writePipes.aa
#define num 8
#include writePipes.aa
