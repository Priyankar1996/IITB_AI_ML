
$module [sendModule] $in () $out () $is
{
    $branchblock [sendBlock]{
        rb := output_pipe
        cb := output_pipe
        chl_out := output_pipe
        max_count := ($bitcast ($uint<32>) (rb*cb))
        row_size := ($bitcast ($uint<32>) (chl_out*cb))
        three_row_size := (row_size*3)

        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address1 := ($bitcast ($uint<32>) 0) $on $entry n_address1 $on $loopback
        $phi address2 := ($bitcast ($uint<32>) row_size) $on $entry n_address2 $on $loopback
        $phi chl := ($bitcast ($uint<16>) 0) $on $entry n_chl $on $loopback
        $phi col := ($bitcast ($uint<16>) 1) $on $entry n_col $on $loopback
        $phi row := ($bitcast ($uint<16>) 1) $on $entry n_row $on $loopback
        $endmerge

        $volatile row_change := (col == cb)

        // Check this later - odd values of row will be incorrect
        $volatile chl_change := (row_change & (row >= (rb - 1)))
        $volatile n_col := ($mux row_change 1 (col + 1))
        $volatile n_row := ($mux chl_change 1 ($mux row_change (row + N_ROWS_S) row))
        $volatile n_chl := ($mux chl_change (chl+1) chl)
        
        $volatile tmp1 := (address1 + ($bitcast ($uint<32>) chl_out))
        $volatile tmp2 := (address2 + ($bitcast ($uint<32>) chl_out))
        $volatile n_address1 := ($mux chl_change ($bitcast ($uint<32>) n_chl) ($mux row_change (tmp1+row_size) tmp1))
        $volatile n_address2 := ($mux chl_change (($bitcast ($uint<32>) n_chl)+row_size) ($mux row_change (tmp2+row_size) tmp2))
        
        $call writeModule1 (2 address1 output_pipe1) (d1)
        $call writeModule1 (2 address2 output_pipe2) (d2)
//        maxpool_output_pipe := 100
        continue_flag := ((chl < (chl_out - 1)) | (~chl_change))
        $while continue_flag
        input_done_pipe := 1
    }
}
