// Access the input tensor and write to iput pipe
$module [access_T]
$in(row_in ct chl_in chl_out rk pad: $uint<16>)
$out()
$is
{
    $branchblock [access_block]
    {
	ct_new := (ct + (pad<<1))
	row_size_total := ($bitcast ($uint<32>) (ct_new * chl_in))
	p_chl_in := ($bitcast ($uint<32>) (pad*chl_in))
	m_factor := ($bitcast ($uint<32>) (ct*chl_in))
	m2_factor := (m_factor << 1)
	m3_factor := (m2_factor+m_factor)
	m4_factor := (m2_factor << 2)
	mode_3 := (rk == 3)
	addr_init := (-1*(($bitcast ($uint<32>) pad)*m_factor))

        // Pipeline for sending inputs
        $dopipeline $depth 15 $buffering 2 $fullrate
        $merge $entry $loopback
        $phi address := addr_init $on $entry n_address $on $loopback
        $phi row1 := ($bitcast ($uint<16>) 0) $on $entry n_row1 $on $loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on $loopback
        $phi mycounter := ($bitcast ($uint<32>) row_size_total) $on $entry n_mycounter $on $loopback
        $endmerge
        
        // $call timer (4) (time_pipe)
        $volatile next_row :=  (mycounter == 1)
        $volatile tmp_cnt := (mycounter - 1)
        $volatile n_mycounter := ($mux next_row row_size_total tmp_cnt ) 
        
	$volatile update_row := ($mux next_row (row1 + N_ROWS_S) row1 )
	$volatile continue_flag1 := (update_row < row_in)
	$volatile mc_lt_p := ((mycounter <= p_chl_in) | (mycounter > (row_size_total - p_chl_in))) 
	$volatile n_row1 := ($mux continue_flag1 update_row 0)
	$volatile n_address := ($mux continue_flag1 (address + ($mux next_row m_factor ($mux mc_lt_p 0 1))) addr_init)
		
	$volatile p1_zero := (mc_lt_p | ((row1 < pad) | (row1 >= ((row_in + 3) - pad))))
	$volatile p2_zero := (mc_lt_p | (((row1+1) < pad) | (row1 >= ((row_in + 2)- pad))))
	$volatile p3_zero := (mc_lt_p | (((row1+2) < pad) | (row1 >= ((row_in + 1)- pad))))
	$volatile p4_zero := (mc_lt_p | (((row1+3) < pad) | (row1 >= (row_in - pad))))
	$volatile addr2 := (address+ m_factor)
	$volatile addr3 := (address+ m2_factor)
	$volatile addr4 := (address+ m3_factor)
	$guard (~p1_zero) val1 := T[0][address]
	$guard (~p2_zero) val2 := T[0][addr2]
	$guard (~p3_zero) val3 := T[0][addr3]
	$guard (~p4_zero) val4 := T[0][addr4]

	core_ip1 := ($mux p1_zero 0 val1)
	core_ip2 := ($mux p2_zero 0 val2)
	core_ip3 := ($mux p3_zero 0 val3)
	$guard (mode_3) core_ip4 := ($mux p4_zero 0 val4)

        $volatile n_chl_num := ($mux continue_flag1 chl_num (chl_num + 1))
        $volatile not_end_flag := ((n_chl_num != chl_out) | continue_flag1)

        $while not_end_flag

        // $call timer (101) (time_pipe)
    }
}
