// Load the kernel channel into the kernel pipes
$module [loadKernel1]
$in (chl_in chl_out rk ck : $uint<16> index : $uint<8>)
$out ()
$is
{  
	
	$branchblock [load_block]
	{ 
		row_size := (chl_in * ck)
		chl8_size := (($bitcast ($uint<32>) (row_size * rk)) << 3)
		count_update := (chl8_size - ($bitcast ($uint<32>) row_size))
		rk_s := ($bitcast ($uint <2>) rk)
		addr_init := 0
		
		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi chl_num := ($bitcast ($uint<16>) 1) $on $entry n_chl_num $on $loopback
		$phi send_cnt := 0 $on $entry n_send_cnt $on $loopback
		$phi ind := ($bitcast ($uint<2>) 1) $on $entry n_ind $on $loopback
		
		$phi data := ($bitcast ($uint<64> 0) $on $entry n_data $on $loopback
		$phi fetch := K[0][(addr_init>>3)] $on $entry n_fetch $on $loopback

		$phi addr := addr_init $on $entry n_addr $on $loopback		
		$phi left := chl_in $on $entry n_left $on $loopback
		$phi ea := ($bitcast ($uint<32>) (ck - 1)) $on $entry n_ea $on $loopback
		$phi head := ($bitcast ($uint<3>) 7) $on $entry n_head $on $loopback
		$endmerge
		
		tmp1 := ($mux 
		n_chl_num := ($mux nxt_chl (chl_num + 8) chl_num)
		
		$volatile exit_cond := (nxt_chl & (n_chl_num > chl_out))
		$while (~exit_cond)
	}
}
