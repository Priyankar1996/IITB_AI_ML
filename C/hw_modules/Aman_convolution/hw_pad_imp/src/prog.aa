// Aa code produced by llvm2aa (version 1.0)
$record [structx_x__SizedTensor_16K] < $array [16384] $of $uint<64> > 
$pipe maxpool_input_pipe : $uint<8> $depth 2
$pipe maxpool_output_pipe : $uint<8> $depth 2
$pipe time_pipe : $uint<64> $depth 2
$parameter NO_ACT 0
$parameter RELU 1
$storage T:structx_x__SizedTensor_16K
$storage K:structx_x__SizedTensor_16K
$storage B:structx_x__SizedTensor_16K
$module [progx_xoptx_xo_storage_initializer_] $in () $out () $is 
{
  $null
  $attribute initializer
}
$module [sendB] 
$in (size : $uint<32> )
$out ()
$is 
{
  $branchblock [body] 
  {
	//begin: basic-block entry
	$place [forx_xbodyx_xpreheader_forx_xbody]
	//begin: basic-block forx_xbody
	$merge forx_xbody_forx_xbody forx_xbodyx_xpreheader_forx_xbody
	$phi ix_x067 :=  ( $cast ($uint<32>) inc) $on forx_xbody_forx_xbody 0 $on forx_xbodyx_xpreheader_forx_xbody 
	$endmerge
	arrayidx := @(B[0][ix_x067])
	// load 
	tmp4 := ->(arrayidx)
	$split (tmp4 8 8 8 8 8 8 8 8) (conv47 conv41 conv35 conv29 conv23 conv17 conv11 conv)

	maxpool_output_pipe := conv47
	maxpool_output_pipe := conv41
	maxpool_output_pipe := conv35
	maxpool_output_pipe := conv29
	maxpool_output_pipe := conv23
	maxpool_output_pipe := conv17
	maxpool_output_pipe := conv11
	maxpool_output_pipe := conv
	inc := (ix_x067 + 1  )
	// compare instruction
	exitcond1 := (inc == size )
	$if exitcond1 $then  $place [forx_xbody_forx_xendx_xloopexit] $else $place [forx_xbody_forx_xbody] $endif 
	//begin: basic-block forx_xendx_xloopexit
	$merge  forx_xbody_forx_xendx_xloopexit
	$endmerge
  }
}

$module [topModule] $in () $out() $is
{
	$seriesblock [seriesBlock]
	{
		$call configureConvolution() (rt ct chl_in rb cb chl_out rk ck shift_val pad op_size scale_val)
		chl_out_ceil := ((chl_out + 7)>>3)
		chl_in_ceil := ((chl_in + 7)>>3)
		
		// Creating partitions
		$call Divider (K_DEPTH (chl_in_ceil*ck)) (alpha)
		cnd_partition := (alpha < chl_out_ceil)
		$guard (cnd_partition) $call Divider ((chl_out_ceil-1) alpha) (tmp1)
		parts := ($bitcast ($uint<8>) ($mux cnd_partition tmp1 0))
		max_per_part := ($mux cnd_partition (alpha<<3) chl_out)
		max_per_part2 := ($mux cnd_partition alpha chl_out_ceil)
	
		$parallelblock [topBlocks]
		{
			$branchblock [time_start_block]
			{
			$call timer (1)  (start_time)
			time_pipe := start_time
			}(start_time => start_time)
			

			$call loadKernel (chl_in chl_out rk ck 1) ()
			$call access_T (rb rt ct chl_in rk pad parts) ()
			//$call inputModule8 (rb ct chl_in rk pad parts) ()
			$call convolveCore (rb cb chl_in_ceil chl_out rk ck parts max_per_part) ()
			$call accumulator (chl_in_ceil ck (op_size >> 1)) ()
			$call sendModule (rb cb chl_out shift_val parts max_per_part RELU scale_val) ()
			//$call sendPool (rb cb chl_out_ceil shift_val parts max_per_part2 NO_ACT ) ()
		}(start_time => start_time)
		
		$call timer (2)  (end_time)
		time_pipe := end_time
		$call sendB(op_size) ()
		net_time := (end_time - start_time)
		$split (net_time 32 8 8 8 8) (not_needed t4 t3 t2 t1)
		maxpool_output_pipe := t4
		maxpool_output_pipe := t3
		maxpool_output_pipe := t2
		maxpool_output_pipe := t1
	}
}

$module [configureConvolution]
$in ()
$out (add add13 add23 add33 add43 add53 add63 add73 shft pad: $uint<16> mul233 scale_val : $uint<32> )
$is
{
	$branchblock [body] 
  {
	//begin: basic-block entry

		add := ($concat maxpool_input_pipe maxpool_input_pipe)
		add13 := (maxpool_input_pipe && maxpool_input_pipe)
		add23 := (maxpool_input_pipe && maxpool_input_pipe)
		add33 := (maxpool_input_pipe && maxpool_input_pipe)
		add43 := (maxpool_input_pipe && maxpool_input_pipe)
		add53 := (maxpool_input_pipe && maxpool_input_pipe)
		add63 := (maxpool_input_pipe && maxpool_input_pipe)
		add73 := (maxpool_input_pipe && maxpool_input_pipe)
		shft := (maxpool_input_pipe && maxpool_input_pipe)
		pad := (maxpool_input_pipe && maxpool_input_pipe)
		scale_val := ((maxpool_input_pipe && maxpool_input_pipe) && (maxpool_input_pipe && maxpool_input_pipe))
		shr80235 := (add53 >> 3)
		shr234 := (add23 >> 3)
		$place [entry_bbx_xnph244]
		//begin: basic-block bbx_xnph244
		$merge entry_bbx_xnph244
		$endmerge
		
		
		$call TopMult (($cast ($uint<32>) add) ($cast ($uint<32>) add13) ) (tmp2)
		tmp4 := ($cast ($uint<32>) add23)
		$call TopMult (tmp2 tmp4) (tmp5)
		$place [bbx_xnph244_forx_xbody]
		//begin: basic-block forx_xbody
		$merge bbx_xnph244_forx_xbody forx_xbody_forx_xbody
		$phi ix_x0243 :=  0 $on bbx_xnph244_forx_xbody ( $cast ($uint<32>) inc) $on forx_xbody_forx_xbody 
		$phi send_datat := ($bitcast ($uint<64>) 0) $on bbx_xnph244_forx_xbody next_send_datat $on forx_xbody_forx_xbody
		$endmerge
		arrayidx := @(T[0][(ix_x0243>>3)])
		next_send_datat := ($concat ($slice send_datat 55 0) maxpool_input_pipe)
		send_condt := (($bitcast ($uint<3>) ix_x0243) == 7)
		$guard (send_condt) ->(arrayidx) := next_send_datat
		inc := (ix_x0243 + 1  )
		// compare instruction
		exitcond6 := (inc == tmp5 )
		$if exitcond6 $then $place [forx_xbody_forx_xendx_xloopexit] $else $place [forx_xbody_forx_xbody] $endif 
		
		//begin: basic-block bbx_xnph
		$merge forx_xbody_forx_xendx_xloopexit
		$endmerge
		data_leftt := (8 - ($bitcast ($uint<3>) tmp5))
		send_remainingt := (data_leftt != 0)
		data_to_sendt := (next_send_datat << (($bitcast ($uint<64>) data_leftt)<<3))
		$guard (send_remainingt) ->(arrayidx) := data_to_sendt
		
		
		$call TopMult (($cast ($uint<32>) add63) ($cast ($uint<32>) add23)) (tmp8)
		$call TopMult (($cast ($uint<32>) add73) ($cast ($uint<32>) add53)) (tmp9)
		$call TopMult (tmp8 tmp9) (tmp13)
		$place [bbx_xnph_forx_xbody158]
		//begin: basic-block forx_xbody158
		$merge bbx_xnph_forx_xbody158 forx_xbody158_forx_xbody158
		$phi ix_x1241 :=  0 $on bbx_xnph_forx_xbody158 ( $cast ($uint<32>) inc208) $on forx_xbody158_forx_xbody158 
		$phi send_data := ($bitcast ($uint<64>) 0) $on bbx_xnph_forx_xbody158 next_send_data $on forx_xbody158_forx_xbody158
		$endmerge
		arrayidx205 := @(K[0][(ix_x1241>>3)])
		next_send_data := ($concat ($slice send_data 55 0) maxpool_input_pipe)
		send_cond := (($bitcast ($uint<3>) ix_x1241) == 7)
		$guard (send_cond) ->(arrayidx205) := next_send_data
		inc208 := (ix_x1241 + 1 )
		// compare instruction
		exitcond14 := (inc208 == tmp13 )
		$if exitcond14 $then  $place [forx_xbody158_forx_xend209x_xloopexit] $else $place [forx_xbody158_forx_xbody158] $endif 
		//begin: basic-block forx_xend209x_xloopexit
		
		$merge forx_xbody158_forx_xend209x_xloopexit
		$endmerge
		
		data_left := (8 - ($bitcast ($uint<3>) tmp13))
		send_remaining := (data_left != 0)
		data_to_send := (next_send_data << (($bitcast ($uint<64>) data_left)<<3))
		$guard (send_remaining) ->(arrayidx205) := data_to_send
		
		conv227 := ($cast ($uint<32>) add43)
		conv229 := ($cast ($uint<32>) add33)
		$call TopMult (conv227 conv229) (mul230)
		$call TopMult (mul230 ($cast ($uint<32>) ((add53+7)>>3))) (mul233)
	}
}


$opaque $module [TopMult] $in (in1 : $uint<32> in2 : $uint<32>) $out (output : $uint<32>)
$is
{
	output := (in1 * in2)
}

$opaque $module [Divider] $in (dividend : $uint<16> $divisor : $uint<16>) $out (quotient : $uint<16>) $is
{
	//quotient := dividend/divisor
	$branchblock [DivBlock]
	{
		$volatile ext_div := ($bitcast ($uint<17>) dividend)
		
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
		$phi div := ($bitcast ($uint<17>) divisor) $on $entry ndiv $on $loopback
		$phi cnt := ($bitcast ($uint<5>) 0) $on $entry ncnt $on $loopback
		$endmerge
		$volatile cmp := (div >= ext_div)
		$volatile ndiv := (div<<1)
		$volatile ncnt := (cnt + 1)
		$while (~cmp)
		
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
		$phi div_2 := div $on $entry ndiv_2 $on $loopback
		$phi ediv_2 := ext_div $on $entry nediv_2 $on $loopback
		$phi quo := ($bitcast ($uint<16>) 0) $on $entry nq $on $loopback
		$phi cnt2 := cnt $on $entry ncnt2 $on $loopback
		$endmerge
		$volatile cmp2 := (div_2 > ediv_2)
		$volatile ndiv_2 := (div_2 >> 1)
		$volatile nediv_2 := (ediv_2 - ($mux cmp2 0 div_2))
		$volatile ncnt2 := (cnt2 - 1) 
		nq := ((quo << 1) + ($mux cmp2 0 1))
		$while (cnt2 > 0)
		
		quotient := nq
	}	
}
