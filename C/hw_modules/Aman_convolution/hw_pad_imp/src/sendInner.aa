$module [sendInner##num ]
$in (init_addr : $uint<32> rb cb chl_out shift_val : $uint<16> num_parts : $uint<8> max_chl : $uint<16> activation : $uint<1>)
$out ()
$is
{
	$branchblock [SI_blk]
	{
		row_size := ($bitcast ($uint<32>) (chl_out*cb))
		apply_relu := (activation == 1)
		
		$merge $entry loopback
		$phi p_cnt := ($bitcast ($uint<8>) 0) $on $entry np_cnt $on loopback
		$phi chl_max_itr := max_chl $on $entry n_cmi $on loopback
		$phi chl_left := (chl_out - max_chl) $on $entry n_chl_left $on loopback
		$phi addr := init_addr $on $entry n_addr $on loopback
		$endmerge

		chl_change_inc := ($bitcast ($uint<32>) (chl_out - chl_max_itr))
		rs_1 := (row_size + chl_change_inc)

		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi address := ($bitcast ($uint<32>) addr) $on $entry n_address $on $loopback
		$phi chl := ($bitcast ($uint<16>) 1) $on $entry n_chl $on $loopback
		$phi col := ($bitcast ($uint<16>) 1) $on $entry n_col $on $loopback
		$phi row := ($bitcast ($uint<16>) 1) $on $entry n_row $on $loopback
		$endmerge

		// Check this later - odd values of row will be incorrect
		$volatile chl_change := (chl == chl_max_itr)
		$volatile row_change := ((col == cb) & chl_change)
		$volatile n_chl := ($mux chl_change 1 (chl+1))
		$volatile n_col := ($mux row_change 1 ($mux chl_change (col + 1) col))
		$volatile n_row := ($mux row_change (row + N_ROWS_S) row)
		
		$volatile tmp_sum := (1 + ($mux row_change rs_1 ($mux chl_change chl_change_inc 0)))
		$volatile n_address := (address + tmp_sum)
		
		read_val1_1 := output_pipe1_##num
		read_val2_1 := output_pipe2_##num
		read_val3_1 := output_pipe3_##num
		read_val4_1 := output_pipe4_##num
		read_val5_1 := output_pipe5_##num
		read_val6_1 := output_pipe6_##num
		read_val7_1 := output_pipe7_##num
		read_val8_1 := output_pipe8_##num
		tmp1_1 := ($mux (apply_relu & ((read_val1_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val1_1 >> shift_val)))
		tmp2_1 := ($mux (apply_relu & ((read_val2_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val2_1 >> shift_val)))
		tmp3_1 := ($mux (apply_relu & ((read_val3_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val3_1 >> shift_val)))
		tmp4_1 := ($mux (apply_relu & ((read_val4_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val4_1 >> shift_val)))
		tmp5_1 := ($mux (apply_relu & ((read_val5_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val5_1 >> shift_val)))
		tmp6_1 := ($mux (apply_relu & ((read_val6_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val6_1 >> shift_val)))
		tmp7_1 := ($mux (apply_relu & ((read_val7_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val7_1 >> shift_val)))
		tmp8_1 := ($mux (apply_relu & ((read_val8_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val8_1 >> shift_val)))
		$volatile rd1 := ($concat tmp1_1 tmp2_1 tmp3_1 tmp4_1 tmp5_1 tmp6_1 tmp7_1 tmp8_1)
		B[0][address] := rd1

		continue_flag := ((row >= (rb -1)) ~& row_change)
		$while continue_flag
		// $call timer (104) (time_pipe)
		
		$volatile np_cnt := (p_cnt + 1)
		$volatile n_cmi := ($mux (chl_left > max_chl) max_chl chl_left)
		$volatile n_chl_left := (chl_left - n_cmi)
		$volatile n_addr := (addr + ($bitcast ($uint<32>) chl_max_itr))
				
		$if (p_cnt < num_parts) $then $place [loopback] $endif
	}
}
