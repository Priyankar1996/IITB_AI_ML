//

$opaque $module [sendModule] $in (rb cb chl_out shift_val : $uint<16> num_parts : $uint<8> max_chl : $uint<16> activation : $uint<8> index : $uint<8>) $out () $is
{
    $branchblock [sendBlock]{
    	row_size := ($bitcast ($uint<32>) (chl_out*cb))
		apply_relu := (activation == 1)
		
		$merge $entry loopback
		$phi p_cnt := ($bitcast ($uint<8>) 0) $on $entry np_cnt $on loopback
		$phi chl_max_itr := max_chl $on $entry n_cmi $on loopback
		$phi chl_left := (chl_out - max_chl) $on $entry n_chl_left $on loopback
		$phi addr := ($bitcast ($uint<32>) 0) $on $entry n_addr $on loopback
		$endmerge

		chl_change_inc := ($bitcast ($uint<32>) (chl_out - chl_max_itr))
		rs_1 := (row_size + chl_change_inc)

		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi address1 := ($bitcast ($uint<32>) addr) $on $entry n_address1 $on $loopback
		$phi address2 := ($bitcast ($uint<32>) (row_size+addr)) $on $entry n_address2 $on $loopback
		$phi chl := ($bitcast ($uint<16>) 1) $on $entry n_chl $on $loopback
		$phi col := ($bitcast ($uint<16>) 1) $on $entry n_col $on $loopback
		$phi row := ($bitcast ($uint<16>) 1) $on $entry n_row $on $loopback
		$endmerge

		// Check this later - odd values of row will be incorrect
		$volatile chl_change := (chl == chl_max_itr)
		$volatile row_change := ((col == cb) & chl_change)
		$volatile n_chl := ($mux chl_change 1 (chl+1))
		$volatile n_col := ($mux row_change 1 ($mux chl_change (col + 1) col))
		$volatile n_row := ($mux row_change (row + N_ROWS_S) row)
		
		$volatile tmp_sum := (1 + ($mux row_change rs_1 ($mux chl_change chl_change_inc 0)))
		$volatile n_address1 := (address1 + tmp_sum)
		$volatile n_address2 := (address2 + tmp_sum)
		
        read_val1_1 := output_pipe1_1
        read_val2_1 := output_pipe2_1
        read_val3_1 := output_pipe3_1
        read_val4_1 := output_pipe4_1
        read_val5_1 := output_pipe5_1
        read_val6_1 := output_pipe6_1
        read_val7_1 := output_pipe7_1
        read_val8_1 := output_pipe8_1
        read_val1_2 := output_pipe1_2
        read_val2_2 := output_pipe2_2
        read_val3_2 := output_pipe3_2
        read_val4_2 := output_pipe4_2
        read_val5_2 := output_pipe5_2
        read_val6_2 := output_pipe6_2
        read_val7_2 := output_pipe7_2
        read_val8_2 := output_pipe8_2
        tmp1_1 := ($mux (apply_relu & ((read_val1_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val1_1 >> shift_val)))
        tmp2_1 := ($mux (apply_relu & ((read_val2_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val2_1 >> shift_val)))
        tmp3_1 := ($mux (apply_relu & ((read_val3_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val3_1 >> shift_val)))
        tmp4_1 := ($mux (apply_relu & ((read_val4_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val4_1 >> shift_val)))
        tmp5_1 := ($mux (apply_relu & ((read_val5_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val5_1 >> shift_val)))
        tmp6_1 := ($mux (apply_relu & ((read_val6_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val6_1 >> shift_val)))
        tmp7_1 := ($mux (apply_relu & ((read_val7_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val7_1 >> shift_val)))
        tmp8_1 := ($mux (apply_relu & ((read_val8_1[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val8_1 >> shift_val)))
        tmp1_2 := ($mux (apply_relu & ((read_val1_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val1_2 >> shift_val)))
        tmp2_2 := ($mux (apply_relu & ((read_val2_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val2_2 >> shift_val)))
        tmp3_2 := ($mux (apply_relu & ((read_val3_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val3_2 >> shift_val)))
        tmp4_2 := ($mux (apply_relu & ((read_val4_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val4_2 >> shift_val)))
        tmp5_2 := ($mux (apply_relu & ((read_val5_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val5_2 >> shift_val)))
        tmp6_2 := ($mux (apply_relu & ((read_val6_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val6_2 >> shift_val)))
        tmp7_2 := ($mux (apply_relu & ((read_val7_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val7_2 >> shift_val)))
        tmp8_2 := ($mux (apply_relu & ((read_val8_2[]{ACC_WIDTH-1}) == 1)) 0 ($bitcast ($uint<8>) (read_val8_2 >> shift_val)))
        $volatile rd1 := ($concat tmp1_1 tmp2_1 tmp3_1 tmp4_1 tmp5_1 tmp6_1 tmp7_1 tmp8_1)
        $volatile rd2 := ($concat tmp1_2 tmp2_2 tmp3_2 tmp4_2 tmp5_2 tmp6_2 tmp7_2 tmp8_2)
        $call writeModule_convolution (index address1 rd1) (a1)
        $call writeModule_convolution (index address2 rd2) (a2)

		continue_flag := ((row >= (rb -1)) ~& row_change)
		$while continue_flag
		
		$volatile np_cnt := (p_cnt + 1)
		$volatile n_cmi := ($mux (chl_left > max_chl) max_chl chl_left)
		$volatile n_chl_left := (chl_left - n_cmi)
		$volatile n_addr := (addr + ($bitcast ($uint<32>) chl_max_itr))
				
		$if (p_cnt < num_parts) $then $place [loopback] $endif
        // $call timer (104) (time_pipe)
		//debug_output_pipe := 95

    }
}
