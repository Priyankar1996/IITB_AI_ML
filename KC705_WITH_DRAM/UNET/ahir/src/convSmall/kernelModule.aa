// Load the kernel channel into the kernel pipes
$module [kernelModule_generic]
$in (chl_in chl_out rk ck : $uint<16> index : $uint<8>)
$out ()
$is
{  
	
	$branchblock [load_block]
	{ 
		row_size := (chl_in * ck)
		chl_size := ($bitcast ($uint<32>) (row_size * rk))
		count_update := (chl_size - ($bitcast ($uint<32>) row_size))
		rk_s := ($bitcast ($uint <2>) rk)
		
		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi chl_num := ($bitcast ($uint<16>) 1) $on $entry n_chl_num $on $loopback
		$phi ea := ($bitcast ($uint<32>) (row_size - 1)) $on $entry n_ea $on $loopback
		$phi mycount := ($bitcast ($uint<32>) 0) $on $entry nmycount $on $loopback
		$phi ind := ($bitcast ($uint<2>) 1) $on $entry n_ind $on $loopback
		$endmerge

		$volatile next_row := (ind == rk_s)
		$volatile nxt_chl := ( (mycount == ea) & next_row)
		$volatile nmycount := (mycount + ($mux next_row (1 + ($mux nxt_chl count_update 0)) 0))
		$volatile n_chl_num := ($mux nxt_chl (chl_num + 1) chl_num)
		$volatile n_ea := (ea + ($mux nxt_chl chl_size 0))
		$volatile n_ind := ($mux next_row 1 (ind + 1))
		$volatile add_val := ($bitcast ($uint<32> )($excmux (ind == 2) row_size (ind == 3) (row_size<<1)))
		
		$call readModule_convolutionk (index ((mycount+add_val)>>3)) (fetch_val1)
		
		$volatile val1 := ($bitcast ($uint<8>) (fetch_val1 >> (($bitcast ($uint<64>) (7-((mycount+add_val)&7)))<<3)))

		$call writeToPipe (ind val1) (a1)
		
		$volatile exit_cond := (nxt_chl & (chl_num == chl_out))

		//debug_output_pipe := ($bitcast ($uint<8>) chl_num)

		$while (~exit_cond)
		//debug_output_pipe := 71
	}
}

#define num 1
#include writePipes.aa
