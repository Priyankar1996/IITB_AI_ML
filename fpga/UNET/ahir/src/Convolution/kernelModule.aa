// Load the kernel channel into the kernel pipes
$module [loadKernel]
$in ()
$out ()
$is
{  
    
    $branchblock [load_block]
    { 
        chl_in := kernel_module_pipe
        chl_out := (kernel_module_pipe << 3)
        kernel_size := kernel_module_pipe
        row_size := (chl_in * kernel_size)
        
        $merge $entry reentry
        $endmerge
        
        index := ($bitcast ($uint<8>) kernel_module_pipe)
        
        $merge $entry loopback
        $phi chl_num := ($bitcast ($uint<16>) 0) $on $entry n_chl_num $on loopback
        $phi start_add := ($bitcast ($uint<32>) 0) $on $entry n_start_add $on loopback
        $endmerge

        ea := ((start_add + ( $bitcast ($uint<32> ) row_size)) - 1)

        $volatile last3 := ($bitcast ($uint<3>) chl_num)
        $volatile last3_0 := (last3 == 0)
        $volatile last3_1 := (last3 == 1)
        $volatile last3_2 := (last3 == 2)
        $volatile last3_3 := (last3 == 3)
        $volatile last3_4 := (last3 == 4)
        $volatile last3_5 := (last3 == 5)
        $volatile last3_6 := (last3 == 6)
        $volatile last3_7 := (last3 == 7)
       
            $dopipeline $depth 15 $buffering 2 $fullrate
            $merge $entry $loopback
            $phi mycount := start_add $on $entry nmycount $on $loopback
            $endmerge
    
            $volatile nmycount := (mycount + 1)
            
            $call readModule_convolutionk (index mycount) (fetch_val1)
            $call readModule_convolutionk (index (mycount+ ( $bitcast ($uint<32> ) row_size))) (fetch_val2)
            $call readModule_convolutionk (index (mycount+ ( $bitcast ($uint<32> ) (row_size<<1)))) (fetch_val3)

            $guard (last3_0) $call writeToPipe1 (fetch_val1 fetch_val2 fetch_val3) (a1)
            $guard (last3_1) $call writeToPipe2 (fetch_val1 fetch_val2 fetch_val3) (a2)
            $guard (last3_2) $call writeToPipe3 (fetch_val1 fetch_val2 fetch_val3) (a3)
            $guard (last3_3) $call writeToPipe4 (fetch_val1 fetch_val2 fetch_val3) (a4)
            $guard (last3_4) $call writeToPipe5 (fetch_val1 fetch_val2 fetch_val3) (a5)
            $guard (last3_5) $call writeToPipe6 (fetch_val1 fetch_val2 fetch_val3) (a6)
            $guard (last3_6) $call writeToPipe7 (fetch_val1 fetch_val2 fetch_val3) (a7)
            $guard (last3_7) $call writeToPipe8 (fetch_val1 fetch_val2 fetch_val3) (a8)

            $while (mycount < ea)

        n_chl_num := (chl_num + 1)
        n_start_add := (start_add + ($bitcast ($uint<32>) (kernel_size*row_size)))
        
        cnd := (chl_num == 7)
        $guard (cnd) convStartPipe := 1
        //maxpool_output_pipe := 127

        $if (n_chl_num != chl_out) $then $place [loopback] $endif
        
        $place [reentry]
    }
}

#define num 1
#include writePipes.aa
#define num 2
#include writePipes.aa
#define num 3
#include writePipes.aa
#define num 4
#include writePipes.aa
#define num 5
#include writePipes.aa
#define num 6
#include writePipes.aa
#define num 7
#include writePipes.aa
#define num 8
#include writePipes.aa
