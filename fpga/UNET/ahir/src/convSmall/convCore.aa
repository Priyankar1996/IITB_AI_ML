// Perform convolution operation
$module [core_generic ]
$in (rb cb chl_in_read chl_out rk ck: $uint<16>)
$out ()
$is
{
	$branchblock [conv_block]
	{
		num_row := (rb - N_ROWS_generic)
		num_col := (cb - 1)
		chl_in := (chl_in_read - 1)
		ck_s := (($bitcast ($uint<2>) ck) - 1)
		mode_2 := (rk == 2)
		not_mode_2 := (~mode_2)
		
		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi row := ($bitcast ($uint<16>) 0) $on $entry ($mux chl_done_flag 0 ($mux row_done (row+N_ROWS_generic) row)) $on $loopback
		$phi col := ($bitcast ($uint<16>) 0) $on $entry ($mux num_done ($mux col_done 0 (col + 1)) col) $on $loopback
		$phi num := ($bitcast ($uint<2>) 0) $on $entry ($mux chl_done ($mux num_done 0 (num+1)) num) $on $loopback
		$phi chl := ($bitcast ($uint<16>) 0) $on $entry ($mux chl_done 0 (chl + 1)) $on $loopback
		$phi chl_out_var := ($bitcast ($uint<16>) 1) $on $entry (chl_out_var + ($mux chl_done_flag 1 0)) $on $loopback
		$endmerge
		
		// $call timer (7) (time_pipe)
		$volatile nd := (num == ck_s)
		$volatile read_ip := ((col == 0) | nd)
		$volatile not_read_ip := (~read_ip)
		$volatile write_input := ((col < num_col) & (num > 0))
		$volatile read_k := ((col == 0) & (row == 0))
		$volatile not_read_k := (~read_k)
		$volatile chl_done := (chl == chl_in)
		$volatile num_done := (nd & chl_done)
		$volatile col_done := (col == num_col)
		$volatile row_done := (col_done & num_done)
		$volatile out_done_flag := (row >= num_row)
		$volatile store_kernel := (out_done_flag ~& col_done)
		$volatile chl_done_flag := (out_done_flag & row_done)
		$volatile all_done_flag := ((chl_out_var == chl_out) & chl_done_flag)
		time_pipe := (($bitcast ($uint<32>) chl_out_var) && ($bitcast ($uint<32>) row))
		
		$volatile read_ip3 := (not_mode_2 & read_ip)
		$volatile not_read_ip3 := (not_mode_2 & not_read_ip)
		$volatile write_input3 := (write_input & not_mode_2)
		#define guard_for_ip1 read_ip
		#define guard_for_ip2 not_read_ip
		#define normal_ip 1
		#define num 1
		#include macro_file2.aa
		#define num 2
		#include macro_file2.aa
		#define num 3
		#include macro_file2.aa
		#define guard_for_ip1 read_ip3
		#define guard_for_ip2 not_read_ip3
		#define normal_ip 0
		#define abnormal_ip 1
		#define num 4
		#include macro_file2.aa
		
		
		$volatile readk_3 := (read_k & not_mode_2)
		$volatile not_readk_3 := (not_read_k & not_mode_2)
		$volatile store_3 := (store_kernel & not_mode_2)
		
		#include convInner.aa
		
		//send_val := ($mux (acc_val < 0) 0 acc_val)
			acc_pipe1 := ($bitcast ($uint<ACC_WIDTH_generic>) acc_val1)
			acc_pipe2 := ($bitcast ($uint<ACC_WIDTH_generic>) acc_val2)

		$while (~all_done_flag)
		// $call timer (102) (time_pipe)
		time_pipe := 45231
	}
}

$module [acc_generic] $in (chl_in ck: $uint<16> op_size : $uint<32>) $out () $is
{
	$branchblock [acc_blk]
	{
		acc_count := ((chl_in * ck) - 1)
		$dopipeline $depth 15 $buffering 2 $fullrate
		$merge $entry $loopback
		$phi acc1_1 := ($bitcast ($uint<16>) 0) $on $entry ($mux num_done 0 acc_val1_1) $on $loopback
		$phi acc1_2 := ($bitcast ($uint<16>) 0) $on $entry ($mux num_done 0 acc_val1_2) $on $loopback
		$phi c_count := ($bitcast ($uint<16>) 0) $on $entry nc_count $on $loopback
		$phi op_count := ($bitcast ($uint<32>) 0) $on $entry nop_count $on $loopback
		$phi t1 := acc_pipe1 $on $entry, $loopback
		$phi r1 := acc_pipe2 $on $entry, $loopback
		$endmerge
		
//		$call timer (8) (time_pipe)
		
		$volatile num_done := (c_count == acc_count)
		$volatile nc_count := ($mux num_done 0 (c_count+1))
		$volatile nop_count := ($mux num_done (op_count+1) op_count)

		//rd1 := acc_pipe1
		//rd2 := acc_pipe2
		//$split (rd1 8 8 8 8 8 8 8 8) (t1 t2 t3 t4 t5 t6 t7 t8)
		$volatile acc_val1_1 := (acc1_1 + t1)
		
//		$split (rd2 8 8 8 8 8 8 8 8) (r1 r2 r3 r4 r5 r6 r7 r8)
		$volatile acc_val1_2 := (acc1_2 + r1)
		
		$guard (num_done) output_pipe1 := acc_val1_1
		$guard (num_done) output_pipe2 := acc_val1_2
			
//		$guard (num_done) $call timer (9) (time_pipe)
		
		$while (nop_count < op_size)
		// $call timer (103) (time_pipe)
		time_pipe := 64521
	}
}
