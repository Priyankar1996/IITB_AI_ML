// Aa code produced by llvm2aa (version 1.0)
$record [structx_x__SizedTensor_16K] < $array [16384] $of $uint<64> > 
$record [structx_x__TensorDescriptor] < $uint<32> > < $uint<32> > < $uint<32> > < $array [64] $of $uint<32> > 
$pipe Block0_complete : $uint<8> $depth 1
$pipe Block0_starting : $uint<8> $depth 1
$pipe zeropad_input_pipe : $uint<8> $depth 2
$pipe zeropad_output_pipe : $uint<8> $depth 2
$storage R:structx_x__SizedTensor_16K
$storage T:structx_x__SizedTensor_16K
$module [progx_xoptx_xo_storage_initializer_] $in () $out () $is 
{
  $null
  $attribute initializer
}
$module [sendOutput] 
$in (size : $uint<32> )
$out ()
$is 
{
  $branchblock [body] 
  {
    //begin: basic-block entry
    shr67 :=  ($bitcast ($uint<32>) ( ($bitcast ( $int<32>) size) >>  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000000010 )  )))
    // compare instruction
    cmp68 := ( ($bitcast ( $int<32>) shr67) >  ($bitcast ( $int<32>) ( $bitcast ($uint<32> ) _b00000000000000000000000000000000 )  ) )
    $if cmp68 $then  $place [entry_bbx_xnph] $else $place [entry_forx_xend] $endif 
    //begin: basic-block bbx_xnph
    $merge entry_bbx_xnph
    $endmerge
    tmp1 := ($cast ($uint<64>) shr67)
    $place [bbx_xnph_forx_xbody]
    //begin: basic-block forx_xbody
    $merge bbx_xnph_forx_xbody forx_xbody_forx_xbody
    $phi indvar :=  ( $cast ($uint<64>) ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000000 ) ) $on bbx_xnph_forx_xbody ( $cast ($uint<64>) indvarx_xnext) $on forx_xbody_forx_xbody 
    $endmerge
    arrayidx := @(R[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][indvar])
    // load 
    tmp4 := ->(arrayidx) 
    conv := ($cast ($uint<8>) tmp4)
    shr9 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    conv12 := ($cast ($uint<8>) shr9)
    shr15 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000010000 ) )
    conv18 := ($cast ($uint<8>) shr15)
    shr21 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000011000 ) )
    conv24 := ($cast ($uint<8>) shr21)
    shr27 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000100000 ) )
    conv30 := ($cast ($uint<8>) shr27)
    shr33 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000101000 ) )
    conv36 := ($cast ($uint<8>) shr33)
    shr39 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000110000 ) )
    conv42 := ($cast ($uint<8>) shr39)
    shr45 := (tmp4 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000111000 ) )
    conv48 := ($cast ($uint<8>) shr45)
    zeropad_output_pipe := conv48
    zeropad_output_pipe := conv42
    zeropad_output_pipe := conv36
    zeropad_output_pipe := conv30
    zeropad_output_pipe := conv24
    zeropad_output_pipe := conv18
    zeropad_output_pipe := conv12
    zeropad_output_pipe := conv
    indvarx_xnext := (indvar + ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000001 ) )
    // compare instruction
    exitcond2 := (indvarx_xnext == tmp1 )
    $if exitcond2 $then  $place [forx_xbody_forx_xendx_xloopexit] $else $place [forx_xbody_forx_xbody] $endif 
    //begin: basic-block forx_xendx_xloopexit
    $merge forx_xbody_forx_xendx_xloopexit
    $endmerge
    $place [forx_xendx_xloopexit_forx_xend]
    //begin: basic-block forx_xend
    $merge entry_forx_xend forx_xendx_xloopexit_forx_xend
    $endmerge
    $place [return__]
    $merge return__ $endmerge
  }
}
$module [zeropad3D_A] 
$in ()
$out ()
$is 
{
  $branchblock [body] 
  {
    //begin: basic-block entry
    inp_d0 := Block0_starting
    inp_d1 := Block0_starting
    inp_d2 := Block0_starting
    out_d0 := Block0_starting
    out_d1 := Block0_starting
    out_d2 := Block0_starting
    padding := Block0_starting
    $barrier 
    //BEGINNING OF Zeropad MODULE
    // Writing the initial data
    //uint16_t k = 0,j1 = col_low,i = row_low,pad_reg = pad,dim2T = tz,\
	//dim1T = ty,dim0T = tx,dim2R = rz,\
	//dim1R = ry,dim0R = rx,dim21T = dim2T*dim1T,\
	//dim21R = dim2R*dim1R,j = j1,break_flag;\
    $volatile i_loop_init := ($bitcast ($uint<8>) 0)
    $volatile j_loop_init := ($bitcast ($uint<8>) 0)
    $volatile k_loop_init := ($bitcast ($uint<8>) 0)
    $volatile src_add_init := ($bitcast ($uint<8>) 0)
    $volatile dest_add_init := ($bitcast ($uint<8>) 0)
    $volatile j1 := ($bitcast ($uint<8>) 0)
    $volatile dim0T := ($cast ($uint<8>) inp_d0)
    $volatile dim1T := ($cast ($uint<8>) inp_d1)
    $volatile dim2T := ($cast ($uint<8>) inp_d2)
    $volatile dim0R := ($cast ($uint<8>) out_d0)
    $volatile dim1R := ($cast ($uint<8>) out_d1)
    $volatile dim2R := ($cast ($uint<8>) out_d2)
    $volatile dim21T := (dim2T * dim1T)
    $volatile dim21R := (dim2R * dim1R)
    $volatile pad := padding
    /////////////////
    
    // Running the loop on the values that are going to change
    $dopipeline $depth 15 $buffering 1 $fullrate
    $merge $entry $loopback
    $phi k_loop := k_loop_init $on $entry next_k_loop $on $loopback
    $phi j_loop := j_loop_init $on $entry next_j_loop $on $loopback
    $phi i_loop := i_loop_init $on $entry next_i_loop $on $loopback
    $phi dest_add := dest_add_init $on $entry next_dest_add $on $loopback
    $phi src_add := src_add_init $on $entry next_src_add $on $loopback
    $endmerge
    
    ///////////////////
    // Creating the indexes for the input and output arrays
    // Now making the expression dest_data_array_idx = (k + dim2R*(j) + dim21R*(i))
    $volatile dest_data_array_idx_1 := (dim2R * j_loop)
    $volatile dest_data_array_idx_2 := (dim21R * i_loop)
    $volatile dest_data_array_idx_3 := (dest_data_array_idx_1 + dest_data_array_idx_2)
    $volatile dest_data_array_idx_4 := (dest_data_array_idx_3 + k_loop)

    // Now making the expression img_data_array_idx = (k + dim2T*(j-pad_reg) + dim21T*(i-pad_reg))
    $volatile img_data_array_idx_1 := (j_loop - pad)
    $volatile img_data_array_idx_2 := (i_loop - pad)
    $volatile img_data_array_idx_3 := (dim2T * img_data_array_idx_1)
    $volatile img_data_array_idx_4 := (dim21T * img_data_array_idx_2)
    $volatile img_data_array_idx_5 := (img_data_array_idx_3 + img_data_array_idx_4)
    $volatile img_data_array_idx_6 := (img_data_array_idx_5 + k_loop )
    
    // Creating the condition to check if the index is within the bounds
    // Now making ((i < (pad_reg)) || (i >= (row_high+pad_reg)) || (j < (pad_reg)) || (j >= (col_high+pad_reg)))
    $volatile i_small_check := (i_loop < pad)
    $volatile j_small_check := (j_loop < pad)
    $volatile i_large_check := (i_loop >= (inp_d0 + pad))
    $volatile j_large_check := (j_loop >= (inp_d1 + pad))
    // To check if data or zero is to be written to the output array
    $volatile data_check1 := (i_small_check | j_small_check)
    $volatile data_check2 := (data_check1 | i_large_check)
    $volatile data_check := (data_check2 | j_large_check)


    // Now Creating the input and output data arrays address for the input and output arrays
    $volatile next_dest_add := (dest_data_array_idx_4 >> 3)
    $volatile next_src_add := (img_data_array_idx_6 >> 3)

    ////////////////////
    iv1 :=  @(T[( $bitcast ($uint<32>) 0)] [( $bitcast ($uint<64>) src_add)])
    i1 := ->(iv1)
    ov :=  @(R[( $bitcast ($uint<32>) 0)] [( $bitcast ($uint<64>) dest_add)])

    //Now writing zero if the condition is true for zeros
    ->(ov) := ($mux data_check ($bitcast ($uint<64>) 0) i1)


    ////////////////////

    //zeropad_output_pipe := i_loop
    //zeropad_output_pipe := j_loop
    //zeropad_output_pipe := k_loop
    ////////////////////

    // Now writing the CHECK BREAK FLAG
    // Now writing the if conditions for the CHECK BREAK FLAG
    // Now making the (k <= dim2T_dif)
    dim2T_dif := (dim2T - 8)
    cmp_dim2 := (k_loop <= dim2T_dif)

    // Now writing the first if the else block conditions
    // Now making the (j == (col_high + (pad_reg<<1)))
    dim1T_check_1 := (pad << 1)
    dim1T_check_2 := ((dim1T + dim1T_check_1) - 1)
    dim1T_check_3 := (j_loop == dim1T_check_2)
    cmp_dim1 := ((~cmp_dim2) & dim1T_check_3)

    // Now writing the second if the else block conditions
    // Now making the (i == (row_high + (pad_reg<<1)))
    dim0T_check_1 := (pad << 1)
    dim0T_check_2 := ((dim0T + dim0T_check_1) - 1)
    dim0T_check_3 := (i_loop == dim0T_check_2)
    cmp_dim0 := ((~cmp_dim2) & dim0T_check_3)

    // Now writing the contents of the if block of the CHECK BREAK FLAG
    //check_if_true := (k_loop + 8)          
    // Here we make k = k + 8 or 0
    next_k_loop := ($mux cmp_dim2 (k_loop + 8) 0)
    // Here we make j = j + 1 or 0
    next_j_loop := ($mux cmp_dim2 j_loop ($mux cmp_dim1 j1 (j_loop + 1)))

    // Now writing the contents of the else block starting of the CHECK BREAK FLAG
    //check_if_false := (j_loop + 1)
    //next_j_loop := ($mux cmp_dim1 j1 j_loop)
    // Here we make i = i + 1 or i
    next_i_loop := ($mux cmp_dim1 (i_loop + 1) i_loop)

    // Now writing the contents of the else block and the its first if block, of the CHECK BREAK FLAG
    //check_if_else_1 := (i_loop + 1) 
    //flag := ($mux cmp_dim0 0 1)
    // Here we make flag = 1 or 0
    flag := (~cmp_dim0)
    
    ////
    //zeropad_output_pipe := j_loop

    ////////////////////
    // Now checking the flag to determine if the loop should be broken
    //cont_flag := (~flag)
    $while flag
    
    //ENDING OF Zeropad MODULE
    $barrier 
    Block0_complete := ( $bitcast ($uint<8> ) _b00000001 ) 
    $place [return__]
    $merge return__ $endmerge
  }
}
$module [zeropad3D] 
$in ()
$out ()
$is 
{
  $branchblock [body] 
  {
    //begin: basic-block entry
    call := zeropad_input_pipe
    call2 := zeropad_input_pipe
    call6 := zeropad_input_pipe
    call11 := zeropad_input_pipe
    call16 := zeropad_input_pipe
    conv19 := ($cast ($uint<64>) call16)
    shl20 := (conv19 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call21 := zeropad_input_pipe
    conv22 := ($cast ($uint<64>) call21)
    add23 := (shl20 | conv22)
    call25 := zeropad_input_pipe
    conv28 := ($cast ($uint<64>) call25)
    shl29 := (conv28 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call30 := zeropad_input_pipe
    conv31 := ($cast ($uint<64>) call30)
    add32 := (shl29 | conv31)
    call34 := zeropad_input_pipe
    conv37 := ($cast ($uint<64>) call34)
    shl38 := (conv37 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call39 := zeropad_input_pipe
    conv40 := ($cast ($uint<64>) call39)
    add41 := (shl38 | conv40)
    call43 := zeropad_input_pipe
    call44 := zeropad_input_pipe
    conv47 := ($cast ($uint<32>) call44)
    shl48 := (conv47 << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    call49 := zeropad_input_pipe
    conv50 := ($cast ($uint<32>) call49)
    add51 := (shl48 | conv50)
    call53 := zeropad_input_pipe
    conv56 := ($cast ($uint<32>) call53)
    shl57 := (conv56 << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    call58 := zeropad_input_pipe
    conv59 := ($cast ($uint<32>) call58)
    add60 := (shl57 | conv59)
    call62 := zeropad_input_pipe
    conv65 := ($cast ($uint<32>) call62)
    shl66 := (conv65 << ( $bitcast ($uint<32> ) _b00000000000000000000000000001000 ) )
    call67 := zeropad_input_pipe
    conv68 := ($cast ($uint<32>) call67)
    add69 := (shl66 | conv68)
    mul := (add23 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000100000 ) )
    mul78 := (mul * add32)
    sext := (mul78 * add41)
    conv79 :=  ($bitcast ($uint<64>) ( ($bitcast ( $int<64>) sext) >>  ($bitcast ( $int<64>) ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000100000 )  )))
    // compare instruction
    cmp229 := (conv79 > ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000111 )  )
    $if cmp229 $then  $place [entry_bbx_xnph] $else $place [entry_forx_xend] $endif 
    //begin: basic-block bbx_xnph
    $merge entry_bbx_xnph
    $endmerge
    shr := (conv79 >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000011 ) )
    // compare instruction
    tmp1 := (shr > ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000001 )  )
    umax2 := ( $mux tmp1 shr ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000001 ) )
    $place [bbx_xnph_forx_xbody]
    //begin: basic-block forx_xbody
    $merge bbx_xnph_forx_xbody forx_xbody_forx_xbody
    $phi indvar :=  ( $cast ($uint<64>) ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000000 ) ) $on bbx_xnph_forx_xbody ( $cast ($uint<64>) indvarx_xnext) $on forx_xbody_forx_xbody 
    $endmerge
    arrayidx := @(T[( $bitcast ($uint<32> ) _b00000000000000000000000000000000 ) ][indvar])
    call85 := zeropad_input_pipe
    conv86 := ($cast ($uint<64>) call85)
    shl88 := (conv86 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call89 := zeropad_input_pipe
    conv91 := ($cast ($uint<64>) call89)
    add92 := (shl88 | conv91)
    shl94 := (add92 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call95 := zeropad_input_pipe
    conv97 := ($cast ($uint<64>) call95)
    add98 := (shl94 | conv97)
    shl100 := (add98 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call101 := zeropad_input_pipe
    conv103 := ($cast ($uint<64>) call101)
    add104 := (shl100 | conv103)
    shl106 := (add104 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call107 := zeropad_input_pipe
    conv109 := ($cast ($uint<64>) call107)
    add110 := (shl106 | conv109)
    shl112 := (add110 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call113 := zeropad_input_pipe
    conv115 := ($cast ($uint<64>) call113)
    add116 := (shl112 | conv115)
    shl118 := (add116 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call119 := zeropad_input_pipe
    conv121 := ($cast ($uint<64>) call119)
    add122 := (shl118 | conv121)
    shl124 := (add122 << ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    call125 := zeropad_input_pipe
    conv127 := ($cast ($uint<64>) call125)
    add128 := (shl124 | conv127)
    ->(arrayidx) := add128
    indvarx_xnext := (indvar + ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000000001 ) )
    // compare instruction
    exitcond3 := (indvarx_xnext == umax2 )
    $if exitcond3 $then  $place [forx_xbody_forx_xendx_xloopexit] $else $place [forx_xbody_forx_xbody] $endif 
    //begin: basic-block forx_xendx_xloopexit
    $merge forx_xbody_forx_xendx_xloopexit
    $endmerge
    $place [forx_xendx_xloopexit_forx_xend]
    //begin: basic-block forx_xend
    $merge entry_forx_xend forx_xendx_xloopexit_forx_xend
    $endmerge
    $barrier 
    $call timer ()  (call133)
    conv134 :=  ($bitcast ($uint<64>) ( $cast ($int< 64 > ) call133) )
    $barrier 
    Block0_starting := call21
    Block0_starting := call30
    Block0_starting := call39
    Block0_starting := call49
    Block0_starting := call58
    Block0_starting := call67
    Block0_starting := call43
    $barrier 
    call149 := Block0_complete
    $barrier 
    $call timer ()  (call152)
    conv153 :=  ($bitcast ($uint<64>) ( $cast ($int< 64 > ) call152) )
    sub := (conv153 - conv134)
    $barrier 
    conv159 := ($cast ($uint<8>) sub)
    shr162 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000001000 ) )
    conv165 := ($cast ($uint<8>) shr162)
    shr168 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000010000 ) )
    conv171 := ($cast ($uint<8>) shr168)
    shr174 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000011000 ) )
    conv177 := ($cast ($uint<8>) shr174)
    shr180 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000100000 ) )
    conv183 := ($cast ($uint<8>) shr180)
    shr186 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000101000 ) )
    conv189 := ($cast ($uint<8>) shr186)
    shr192 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000110000 ) )
    conv195 := ($cast ($uint<8>) shr192)
    shr198 := (sub >> ( $bitcast ($uint<64> ) _b0000000000000000000000000000000000000000000000000000000000111000 ) )
    conv201 := ($cast ($uint<8>) shr198)
    zeropad_output_pipe := conv201
    zeropad_output_pipe := conv195
    zeropad_output_pipe := conv189
    zeropad_output_pipe := conv183
    zeropad_output_pipe := conv177
    zeropad_output_pipe := conv171
    zeropad_output_pipe := conv165
    zeropad_output_pipe := conv159
    $barrier 
    mul223 := (add60 * add51)
    mul226 := (mul223 * add69)
    $call sendOutput (mul226 )  ()
    $place [return__]
    $merge return__ $endmerge
  }
}
