$parameter MAX_ACC_REG 16
$parameter BITS_MAX_ACC_REG 4

$storage accelerator_reg : $array[MAX_ACC_REG] $of $uint<32>

$pipe start_worker: $uint<1>
$module [accelerator_control_daemon]
	$in () $out () $is
{
	// initialize
	$branchblock[init_loop] {
		$merge $entry loopback 
			$phi I := $zero<BITS_MAX_ACC_REG> $on $entry nI $on loopback
		$endmerge
		$volatile nI := (I + 1)
		accelerator_reg[I] := 0

		$if (I < {MAX_ACC_REG-1}) $then $place[loopback] $endif
	}

	start_worker := 1

	$branchblock[run_loop] {
		$merge $entry loopback $endmerge 

		cmd := AFB_ACCELERATOR_REQUEST
		$volatile $split (cmd 1 1 4 36 32)
				(lock rwbar bmask addr wdata)

		$volatile reg_index := ($slice addr {BITS_MAX_ACC_REG+1} 2)

		// we assume bmask is always 0xf
		$guard (rwbar)    rdata := accelerator_reg[reg_index]
		$guard (~rwbar)   accelerator_reg[reg_index] := wdata

		$volatile resp := ($concat $zero<1> ($mux rwbar rdata 0))
		AFB_ACCELERATOR_RESPONSE := resp

		$place [loopback]
	}
}

$module [accelerator_worker_daemon] $in () $out () $is
{
	sw := start_worker // wait on initialization

	$branchblock[loop] {
		$merge $entry loopback $endmerge	
		

		// spin, wait for command...
		$merge $entry look_for_command $endmerge
			r0 := accelerator_reg[0]
			$volatile cmd_flag := ($reduce & (r0 [] 0) (r0 [] 2) (~(r0 [] 3)))
		$if (~cmd_flag) $then $place [look_for_command] $endif
	
		//clear bits 2, 4 of register 0
		accelerator_reg[0] := (r0 & (~ 36))

		$barrier

		$call execute_job () ()
		
		$barrier

		// set interrupt flag in r0.
		$volatile set_intr := ((r0 [] 0) & (r0 [] 1))
		accelerator_reg[0] := ($concat ($slice r0 31 5) set_intr $one<1> ($slice r0 2 0))


		$place [loopback]
	}
}

$module [accelerator_interrupt_daemon]
	$in () $out () $is
{
	$branchblock[loop] {
		$merge $entry loopback $endmerge

		r0 := accelerator_reg[0]
		ACCELERATOR_INTERRUPT := (r0 [] 4)


	 	$place[loopback]
	}
}
